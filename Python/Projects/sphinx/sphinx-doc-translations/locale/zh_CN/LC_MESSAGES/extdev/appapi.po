# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2020, Georg Brandl and the Sphinx team
# This file is distributed under the same license as the Sphinx package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Georg Brandl <g.brandl@gmx.net>, 2018
# wendi cao <651645601@qq.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sphinx 4.0.0+/d9280e253\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-13 23:32+0000\n"
"PO-Revision-Date: 2018-02-12 13:48+0000\n"
"Last-Translator: wendi cao <651645601@qq.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/sphinx-doc/teams/15434/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../sphinx/doc/extdev/appapi.rst:4
msgid "Application API"
msgstr "应用接口"

#: ../../sphinx/doc/extdev/appapi.rst:10
msgid ""
"Each Sphinx extension is a Python module with at least a :func:`setup` "
"function.  This function is called at initialization time with one argument,"
" the application object representing the Sphinx process."
msgstr ""
"每个Sphinx扩展都是一个Python模块，其中至少有一个：func:`setup`函数。此函数在初始化时使用一个参数调用，即表示Sphinx进程的应用程序对象。"

#: ../../sphinx/doc/extdev/appapi.rst:16
msgid "This application object has the public API described in the following."
msgstr "此应用程序对象具有下面描述的公共接口。"

#: ../../sphinx/doc/extdev/appapi.rst:19
msgid "Extension setup"
msgstr "插件设置"

#: ../../sphinx/doc/extdev/appapi.rst:21
msgid ""
"These methods are usually called in an extension's ``setup()`` function."
msgstr "这些方法通常在扩展的“setup（）”函数中调用。"

#: ../../sphinx/doc/extdev/appapi.rst:23
msgid ""
"Examples of using the Sphinx extension API can be seen in the "
":mod:`sphinx.ext` package."
msgstr "可以在：mod:`sphinx.ext`包装。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.setup_extension:1
msgid "Import and setup a Sphinx extension module."
msgstr "导入并设置Sphinx插件模块。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.setup_extension:3
msgid ""
"Load the extension given by the module *name*.  Use this if your extension "
"needs the features provided by another extension.  No-op if called twice."
msgstr "加载由模块*name*指定的扩展名。如果您的扩展需要其他扩展提供的功能，请使用此选项。如果提示了两次，则无需操作。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.require_sphinx:1
msgid "Check the Sphinx version if requested."
msgstr "检查sphinx版\"if\"请求。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.require_sphinx:3
msgid ""
"Compare *version* (which must be a ``major.minor`` version string, e.g. "
"``'1.1'``) with the version of the running Sphinx, and abort the build when "
"it is too old."
msgstr ""
"比较*版本*（必须是``大调。小调``版本字符串，例如'''1.1'``），与正在运行的Sphinx版本一起使用，如果版本太旧，则中止生成。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.connect:1
msgid "Register *callback* to be called when *event* is emitted."
msgstr "发出*event*时要调用的寄存器*callback*。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.connect:3
msgid ""
"For details on available core events and the arguments of callback "
"functions, please see :ref:`events`."
msgstr "有关可用核心事件和回调函数参数的详细信息，请参阅：ref:`events`。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.connect:6
msgid ""
"Registered callbacks will be invoked on event in the order of *priority* and"
" registration.  The priority is ascending order."
msgstr "已注册的回调将按*优先级*和注册的顺序在事件上调用。优先顺序是升序。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.connect:9
msgid ""
"The method returns a \"listener ID\" that can be used as an argument to "
":meth:`disconnect`."
msgstr "该方法返回一个“listener ID”，可将其用作参数：meth:`disconnect`。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.connect:14
msgid "Support *priority*"
msgstr "支持*优先级*"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.disconnect:1
msgid "Unregister callback by *listener_id*."
msgstr "按*listener_id*取消注册回调。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_builder:1
msgid "Register a new builder."
msgstr "注册一个新的建造者。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_builder:3
msgid ""
"*builder* must be a class that inherits from "
":class:`~sphinx.builders.Builder`."
msgstr "*builder*必须是继承自：class:`~sphinx.builders.Builder`."

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_builder:5
msgid ""
"If *override* is True, the given *builder* is forcedly installed even if a "
"builder having the same name is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_builder:8
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.set_translator:11
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive:38
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role:11
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_generic_role:10
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_domain:10
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive_to_domain:10
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role_to_domain:10
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_index_to_domain:10
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:57
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_crossref_type:30
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodocumenter:15
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_source_parser:10
msgid "Add *override* keyword."
msgstr "添加*覆盖*关键字。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_config_value:1
msgid "Register a configuration value."
msgstr "注册配置值。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_config_value:3
msgid ""
"This is necessary for Sphinx to recognize new values and set default values "
"accordingly.  The *name* should be prefixed with the extension name, to "
"avoid clashes.  The *default* value can be any Python object. The string "
"value *rebuild* must be one of those values:"
msgstr ""
"这对于Sphinx识别新值并相应地设置默认值是必需的。*名称*应以扩展名作为前缀，以避免冲突。*default*值可以是任何Python对象。字符串值*rebuild*必须是以下值之一："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_config_value:8
msgid ""
"``'env'`` if a change in the setting only takes effect when a document is "
"parsed -- this means that the whole environment must be rebuilt."
msgstr "``“env”`如果设置中的更改仅在文档被解析时生效—这意味着必须重新构建整个环境。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_config_value:11
msgid ""
"``'html'`` if a change in the setting needs a full rebuild of HTML "
"documents."
msgstr "``“html”``如果更改设置需要完全重新生成html文档。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_config_value:13
msgid "``''`` if a change in the setting will not need any special rebuild."
msgstr "``''``如果设置中的更改不需要任何特殊的重建。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_config_value:15
msgid ""
"Changed *rebuild* from a simple boolean (equivalent to ``''`` or ``'env'``) "
"to a string.  However, booleans are still accepted and converted internally."
msgstr "将*rebuild*从一个简单的布尔值（相当于'''''或''env'``'）更改为字符串。但是，布尔值仍然被接受并在内部转换。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_config_value:20
msgid ""
"If the *default* value is a callable, it will be called with the config "
"object as its argument in order to get the default value. This can be used "
"to implement config values whose default depends on other values."
msgstr "如果*default*值是可调用的，则将使用config对象作为其参数来调用它，以获取默认值。这可以用来实现默认值依赖于其他值的配置值。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_event:1
msgid "Register an event called *name*."
msgstr "注册一个名为*name*的事件。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_event:3
msgid "This is needed to be able to emit it."
msgstr "这是需要有能力发射它。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.set_translator:1
msgid "Register or override a Docutils translator class."
msgstr "注册或重写Docutils转换器类。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.set_translator:3
msgid ""
"This is used to register a custom output translator or to replace a builtin "
"translator.  This allows extensions to use custom translator and define "
"custom nodes for the translator (see :meth:`add_node`)."
msgstr ""
"它用于注册自定义输出转换器或替换内置转换器。这允许扩展使用自定义转换器，并为转换器定义自定义节点（请参见：meth:`add_node`）。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.set_translator:7
msgid ""
"If *override* is True, the given *translator_class* is forcedly installed "
"even if a translator for *name* is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_node:1
msgid "Register a Docutils node class."
msgstr "注册Docutils节点类。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_node:3
msgid ""
"This is necessary for Docutils internals.  It may also be used in the future"
" to validate nodes in the parsed documents."
msgstr "这对于Docutils内部构件是必需的。将来还可以使用它来验证已解析文档中的节点。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_node:6
msgid ""
"Node visitor functions for the Sphinx HTML, LaTeX, text and manpage writers "
"can be given as keyword arguments: the keyword should be one or more of "
"``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'`` or any other "
"supported translators, the value a 2-tuple of ``(visit, depart)`` methods.  "
"``depart`` can be ``None`` if the ``visit`` function raises "
":exc:`docutils.nodes.SkipNode`.  Example:"
msgstr ""
"Sphinx "
"HTML、LaTeX、text和手册页编写器的节点访问者函数可以作为关键字参数给定：关键字应该是一个或多个“HTML”`、“LaTeX”`、“text”`、“man”`、“texinfo”或任何其他受支持的翻译器，值为“2元组”`（visit，depart）``方法。``如果“visit”函数引发：exc:`docutils.nodes.SkipNode`."
" 例子："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_node:24
msgid ""
"Obviously, translators for which you don't specify visitor methods will "
"choke on the node when encountered in a document to translate."
msgstr "显然，当在要翻译的文档中遇到未指定访问者方法的转换器时，会在节点上卡住。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_node:27
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_enumerable_node:22
msgid ""
"If *override* is True, the given *node* is forcedly installed even if a node"
" having the same name is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_node:30
msgid "Added the support for keyword arguments giving visit functions."
msgstr "增加了对提供访问函数的关键字参数的支持。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_enumerable_node:1
msgid "Register a Docutils node class as a numfig target."
msgstr "将Docutils节点类注册为numfig目标。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_enumerable_node:3
msgid ""
"Sphinx numbers the node automatically. And then the users can refer it using"
" :rst:role:`numref`."
msgstr "Sphinx会自动为节点编号。然后用户可以使用：rst:角色：`numref`。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_enumerable_node:6
msgid ""
"*figtype* is a type of enumerable nodes.  Each figtypes have individual "
"numbering sequences.  As a system figtypes, ``figure``, ``table`` and "
"``code-block`` are defined.  It is able to add custom nodes to these default"
" figtypes.  It is also able to define new custom figtype if new figtype is "
"given."
msgstr ""
"*figtype*是可枚举节点的一种类型。每五种类型都有各自的编号顺序。作为一个系统数字类型，定义了“fig”、“table”和“code "
"block”。它可以向这些默认的figtype添加自定义节点。如果给定了新的figtype，它还可以定义新的figtype。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_enumerable_node:12
msgid ""
"*title_getter* is a getter function to obtain the title of node.  It takes "
"an instance of the enumerable node, and it must return its title as string."
"  The title is used to the default title of references for :rst:role:`ref`."
"  By default, Sphinx searches ``docutils.nodes.caption`` or "
"``docutils.nodes.title`` from the node as a title."
msgstr ""
"*title "
"getter*是一个获取节点标题的getter函数。它接受可枚举节点的实例，并且必须以字符串形式返回其标题。标题用于引用的默认标题：rst:角色：`ref`。默认情况下，sphinx搜索``docutils.nodes.caption``或者``docutils.nodes.title``从节点作为标题。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_enumerable_node:19
msgid ""
"Other keyword arguments are used for node visitor functions. See the "
":meth:`.Sphinx.add_node` for details."
msgstr "其他关键字参数用于节点访问者函数。参见：meth:`。Sphinx.add_节点`了解详情。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive:1
msgid "Register a Docutils directive."
msgstr "注册Docutils指令。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive:3
msgid ""
"*name* must be the prospective directive name.  *cls* is a directive class "
"which inherits ``docutils.parsers.rst.Directive``.  For more details, see "
"`the Docutils docs <http://docutils.sourceforge.net/docs/howto/rst-"
"directives.html>`_ ."
msgstr ""
"*名称*必须是预期指令名称。*cls*是一个指令类，它继承``docutils.parsers.rst。指令``。有关详细信息，请参见Docutils "
"docs<http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_ ."

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive:8
msgid ""
"For example, a custom directive named ``my-directive`` would be added like "
"this:"
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive:31
msgid ""
"If *override* is True, the given *cls* is forcedly installed even if a "
"directive named as *name* is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive:34
msgid "Docutils 0.5-style directive classes are now supported."
msgstr "现在支持Docutils 0.5样式的指令类。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive:36
msgid "Docutils 0.4-style (function based) directives support is deprecated."
msgstr "不推荐使用Docutils 0.4样式（基于函数）指令支持。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role:1
msgid "Register a Docutils role."
msgstr "注册Docutils角色。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role:3
msgid ""
"*name* must be the role name that occurs in the source, *role* the role "
"function. Refer to the `Docutils documentation "
"<http://docutils.sourceforge.net/docs/howto/rst-roles.html>`_ for more "
"information."
msgstr ""
"*name*必须是源中出现的角色名，*role*是role函数。请参阅`Docutils文档<http://docutils.sourceforge.net/docs/howto"
"/rst-roles.html>`_了解更多信息。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role:8
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role_to_domain:6
msgid ""
"If *override* is True, the given *role* is forcedly installed even if a role"
" named as *name* is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_generic_role:1
msgid "Register a generic Docutils role."
msgstr "注册通用Docutils角色。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_generic_role:3
msgid ""
"Register a Docutils role that does nothing but wrap its contents in the node"
" given by *nodeclass*."
msgstr "注册一个Docutils角色，该角色只在*nodeclass*给定的节点中包装其内容。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_generic_role:6
msgid ""
"If *override* is True, the given *nodeclass* is forcedly installed even if a"
" role named as *name* is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_domain:1
msgid "Register a domain."
msgstr "注册域。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_domain:3
msgid ""
"Make the given *domain* (which must be a class; more precisely, a subclass "
"of :class:`~sphinx.domains.Domain`) known to Sphinx."
msgstr ""
"生成给定的*domain*（它必须是一个类；更准确地说，是：class:`~sphinx.Domain.Domain`)让sphinx知道。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_domain:6
msgid ""
"If *override* is True, the given *domain* is forcedly installed even if a "
"domain having the same name is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive_to_domain:1
msgid "Register a Docutils directive in a domain."
msgstr "在域中注册Docutils指令。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive_to_domain:3
msgid ""
"Like :meth:`add_directive`, but the directive is added to the domain named "
"*domain*."
msgstr "例如：meth:`add\\u directive`，但该指令被添加到名为*domain*的域中。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_directive_to_domain:6
msgid ""
"If *override* is True, the given *directive* is forcedly installed even if a"
" directive named as *name* is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role_to_domain:1
msgid "Register a Docutils role in a domain."
msgstr "在域中注册Docutils角色。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_role_to_domain:3
msgid ""
"Like :meth:`add_role`, but the role is added to the domain named *domain*."
msgstr "Like:meth:`add\\u role`，但是角色被添加到名为*domain*的域中。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_index_to_domain:1
msgid "Register a custom index for a domain."
msgstr "注册域的自定义索引。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_index_to_domain:3
msgid ""
"Add a custom *index* class to the domain named *domain*.  *index* must be a "
"subclass of :class:`~sphinx.domains.Index`."
msgstr ""
"向名为*domain*的域添加一个自定义*index*类。*index*必须是：class:`~sphinx.domains.Index`."

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_index_to_domain:6
msgid ""
"If *override* is True, the given *index* is forcedly installed even if an "
"index having the same name is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:1
msgid "Register a new object type."
msgstr "注册一个新的对象类型。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:3
msgid ""
"This method is a very convenient way to add a new :term:`object` type that "
"can be cross-referenced.  It will do this:"
msgstr "这方法是添加一个新的：term:`object`类型的非常方便的方法，可以交叉引用。它将这样做："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:6
msgid ""
"Create a new directive (called *directivename*) for documenting an object.  "
"It will automatically add index entries if *indextemplate* is nonempty; if "
"given, it must contain exactly one instance of ``%s``.  See the example "
"below for how the template will be interpreted."
msgstr ""
"创建一个新的指令（称为*directivename*），用于记录对象。如果*indextemplate*非空，它将自动添加索引项；如果给定，则它必须正好包含一个````实例。有关如何解释模板，请参见下面的示例。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:11
msgid ""
"Create a new role (called *rolename*) to cross-reference to these object "
"descriptions."
msgstr "创建一个新角色（称为*rolename*），以交叉引用这些对象描述。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:13
msgid ""
"If you provide *parse_node*, it must be a function that takes a string and a"
" docutils node, and it must populate the node with children parsed from the "
"string.  It must then return the name of the item to be used in cross-"
"referencing and index entries.  See the :file:`conf.py` file in the source "
"for this documentation for an example."
msgstr ""
"如果提供*parse_node*，它必须是一个接受字符串和docutils节点的函数，并且必须使用从字符串解析的子节点填充节点。然后它必须返回要在交叉引用和索引项中使用的项的名称。请参见：文件：`配置文件`文件在源文件中的示例。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:19
msgid ""
"The *objname* (if not given, will default to *directivename*) names the type"
" of object.  It is used when listing objects, e.g. in search results."
msgstr "*objname*（如果未给定，将默认为*directivename*）命名对象的类型。在列出对象时使用，例如在搜索结果中。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:23
msgid "For example, if you have this call in a custom Sphinx extension::"
msgstr "例如，如果在自定义Sphinx插件中有此调用："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:27
msgid "you can use this markup in your documents::"
msgstr "您可以在文档中使用此标记："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:37
msgid ""
"For the directive, an index entry will be generated as if you had prepended "
"::"
msgstr "对于该指令，将生成一个索引项，就像您预先添加了："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:41
msgid ""
"The reference node will be of class ``literal`` (so it will be rendered in a"
" proportional font, as appropriate for code) unless you give the "
"*ref_nodeclass* argument, which must be a docutils node class.  Most useful "
"are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` -- you can also"
" use ``docutils.nodes.generated`` if you want no further text decoration.  "
"If the text should be treated as literal (e.g. no smart quote replacement), "
"but not have typewriter styling, use ``sphinx.addnodes.literal_emphasis`` or"
" ``sphinx.addnodes.literal_strong``."
msgstr ""
"引用节点将是“literal”类（因此它将以适合代码的比例字体呈现），除非提供*ref_nodeclass*参数，该参数必须是docutils节点类。最有用的是``docutils.nodes.emphasis``或者``docutils.nodes.strong``--您也可以使用``docutils.nodes.generated``如果你不想进一步的文字装饰。如果文本应视为文字（例如，没有智能引号替换），但没有打字机样式，则使用``sphinx.addnodes.literal_强调``或者``sphinx.addnodes.literal_强``."

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:51
msgid ""
"For the role content, you have the same syntactical possibilities as for "
"standard Sphinx roles (see :ref:`xref-syntax`)."
msgstr "对于角色内容，您具有与标准Sphinx角色相同的语法可能性（请参见：ref:`xref syntax`）。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_object_type:54
msgid ""
"If *override* is True, the given object_type is forcedly installed even if "
"an object_type having the same name is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_crossref_type:1
msgid "Register a new crossref object type."
msgstr "注册新的交叉引用对象类型。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_crossref_type:3
msgid ""
"This method is very similar to :meth:`add_object_type` except that the "
"directive it generates must be empty, and will produce no output."
msgstr "此方法与：meth:`add_object_type`非常相似，只是它生成的指令必须为空，并且不会生成任何输出。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_crossref_type:6
msgid ""
"That means that you can add semantic targets to your sources, and refer to "
"them using custom roles instead of generic ones (like :rst:role:`ref`).  "
"Example call::"
msgstr "这意味着您可以将语义目标添加到源代码中，并使用自定义角色而不是通用角色来引用它们（例如：rst:角色：`ref`）。示例调用："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_crossref_type:13
msgid "Example usage::"
msgstr "用法示例："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_crossref_type:24
msgid ""
"(Of course, the element following the ``topic`` directive needn't be a "
"section.)"
msgstr "（当然，``topic``指令后面的元素不必是节。）"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_crossref_type:27
msgid ""
"If *override* is True, the given crossref_type is forcedly installed even if"
" a crossref_type having the same name is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:1
msgid "Register a Docutils transform to be applied after parsing."
msgstr "注册要在解析后应用的Docutils转换。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:3
msgid ""
"Add the standard docutils :class:`Transform` subclass *transform* to the "
"list of transforms that are applied after Sphinx parses a reST document."
msgstr ""
"将标准docutils:class:`Transform` subclass*Transform*添加到Sphinx解析reST文档后应用的转换列表中。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:7
msgid "priority range categories for Sphinx transforms"
msgstr "Sphinx变换的优先级范围类别"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:10
msgid "Priority"
msgstr "优先级"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:11
msgid "Main purpose in Sphinx"
msgstr "sphinx的主要目标"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:12
msgid "0-99"
msgstr "0-99"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:13
msgid "Fix invalid nodes by docutils. Translate a doctree."
msgstr "用docutils修复无效节点。翻译博士论文。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:14
msgid "100-299"
msgstr "100-299"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:15
msgid "Preparation"
msgstr "准备"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:16
msgid "300-399"
msgstr "300-399"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:17
msgid "early"
msgstr "早期的"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:18
msgid "400-699"
msgstr "400-699"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:19
msgid "main"
msgstr "主要的"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:20
msgid "700-799"
msgstr "700-799"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:21
msgid "Post processing. Deadline to modify text and referencing."
msgstr "后置处理。修改文本和引用的截止日期。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:22
msgid "800-899"
msgstr "800-899"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:23
msgid "Collect referencing and referenced nodes. Domain processing."
msgstr "收集引用和引用节点。域处理。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:24
msgid "900-999"
msgstr "900-999"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:25
msgid "Finalize and clean up."
msgstr "完成并清理。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_transform:27
msgid "refs: `Transform Priority Range Categories`__"
msgstr "refs: `Transform Priority Range Categories`__"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_post_transform:1
msgid "Register a Docutils transform to be applied before writing."
msgstr "在编写之前注册要应用的Docutils转换。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_post_transform:3
msgid ""
"Add the standard docutils :class:`Transform` subclass *transform* to the "
"list of transforms that are applied before Sphinx writes a document."
msgstr ""
"将标准docutils:class:`Transform` subclass*Transform*添加到Sphinx编写文档之前应用的转换列表中。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_js_file:1
msgid "Register a JavaScript file to include in the HTML output."
msgstr "注册一个JavaScript文件以包含在HTML输出中。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_js_file:3
msgid ""
"Add *filename* to the list of JavaScript files that the default HTML "
"template will include.  The filename must be relative to the HTML static "
"path , or a full URI with scheme.  If the keyword argument ``body`` is "
"given, its value will be added between the ``<script>`` tags. Extra keyword "
"arguments are included as attributes of the ``<script>`` tag."
msgstr ""
"将*filename*添加到默认HTML模板将包含的JavaScript文件列表中。文件名必须是相对于HTML静态路径的，或者是包含scheme的完整URI。如果给定关键字参数“body”，则其值将被添加到“1”标记之间。额外的关键字参数作为“2”标记的属性包含在内。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_js_file:10
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_css_file:8
msgid "Example::"
msgstr "例如："

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_js_file:23
msgid ""
"Renamed from ``app.add_javascript()``. And it allows keyword arguments as "
"attributes of script tag."
msgstr "重命名自``app.add_javascript应用程序()``. 它允许关键字参数作为脚本标记的属性。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_css_file:1
msgid "Register a stylesheet to include in the HTML output."
msgstr "注册要包含在HTML输出中的样式表。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_css_file:3
msgid ""
"Add *filename* to the list of CSS files that the default HTML template will "
"include.  The filename must be relative to the HTML static path, or a full "
"URI with scheme.  The keyword arguments are also accepted for attributes of "
"``<link>`` tag."
msgstr ""
"将*filename*添加到默认HTML模板将包含的CSS文件列表中。文件名必须是相对于HTML静态路径的，或者是包含scheme的完整URI。关键字参数也可用于“1”标记的属性。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_css_file:23
msgid ""
"Optional ``alternate`` and/or ``title`` attributes can be supplied with the "
"*alternate* (of boolean type) and *title* (a string) arguments. The default "
"is no title and *alternate* = ``False``. For more information, refer to the "
"`documentation <https://mdn.io/Web/CSS/Alternative_style_sheets>`__."
msgstr ""
"可选的“alternate”和/或“title”属性可以与*alternate*（布尔类型）和*title*（字符串）参数一起提供。默认值是no "
"title和*alternate*=``False``。有关详细信息，请参阅文档<https://mdn.io/Web/CSS/Alternative_样式表>`__."

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_css_file:30
msgid ""
"Renamed from ``app.add_stylesheet()``. And it allows keyword arguments as "
"attributes of link tag."
msgstr "重命名自``app.add_样式表()``. 它允许关键字参数作为链接标记的属性。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_latex_package:1
msgid "Register a package to include in the LaTeX source code."
msgstr "注册包，以包含在LaTeX源代码中。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_latex_package:3
msgid ""
"Add *packagename* to the list of packages that LaTeX source code will "
"include.  If you provide *options*, it will be taken to `\\usepackage` "
"declaration.  If you set *after_hyperref* truthy, the package will be loaded"
" after ``hyperref`` package."
msgstr ""
"将*packagename*添加到LaTeX源代码将包含的包列表中。如果您提供*options*，它将被带到“\\usepackage”声明中。如果您在“hyperref*truthy”之后设置“*”，则包将在“hyperref”包之后加载。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_latex_package:18
msgid "*after_hyperref* option."
msgstr "*在_hyperref*选项之后。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_lexer:1
msgid "Register a new lexer for source code."
msgstr "为源代码注册一个新的分析程序。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_lexer:3
msgid "Use *lexer* to highlight code blocks with the given language *alias*."
msgstr "使用*lexer*突出显示具有给定语言*alias*的代码块。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_lexer:6
msgid ""
"Take a lexer class as an argument.  An instance of lexers are still "
"supported until Sphinx-3.x."
msgstr "以lexer类作为参数。在Sphinx-3.x之前，lexer的一个实例仍然受支持。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodocumenter:1
msgid "Register a new documenter class for the autodoc extension."
msgstr "为自动文档插件注册一个新的documenter类。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodocumenter:3
msgid ""
"Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc` "
"extension.  It must be a subclass of :class:`sphinx.ext.autodoc.Documenter`."
"  This allows to auto-document new types of objects.  See the source of the "
"autodoc module for examples on how to subclass :class:`Documenter`."
msgstr ""
"将*cls*添加为：mod:`斯芬克斯.ext.autodoc`扩展。它必须是类的子类：`斯芬克斯.ext.autodoc.Documenter`。这允许自动记录新类型的对象。有关如何子类class:`Documenter`，请参阅autodoc模块的源代码。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodocumenter:9
msgid ""
"If *override* is True, the given *cls* is forcedly installed even if a "
"documenter having the same name is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodocumenter:12
msgid "Todo"
msgstr "待处理"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodocumenter:12
msgid "Add real docs for Documenter and subclassing"
msgstr "为Documenter和子类化添加真实的文档"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodoc_attrgetter:1
msgid "Register a new ``getattr``-like function for the autodoc extension."
msgstr "为自动文档插件注册一个类似“getattr”的新函数。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_autodoc_attrgetter:3
msgid ""
"Add *getter*, which must be a function with an interface compatible to the "
":func:`getattr` builtin, as the autodoc attribute getter for objects that "
"are instances of *typ*.  All cases where autodoc needs to get an attribute "
"of a type are then handled by this function instead of :func:`getattr`."
msgstr ""
"添加*getter*，它必须是一个接口与：func:`getattr`内置函数兼容的函数，作为*typ*实例的对象的autodoc属性getter。自动文档需要获取某个类型属性的所有情况都由该函数处理，而不是：func:`getattr`。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_search_language:1
msgid "Register a new language for the HTML search index."
msgstr "为HTML搜索索引注册一种新语言。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_search_language:3
msgid ""
"Add *cls*, which must be a subclass of "
":class:`sphinx.search.SearchLanguage`, as a support language for building "
"the HTML full-text search index.  The class must have a *lang* attribute "
"that indicates the language it should be used for.  See "
":confval:`html_search_language`."
msgstr ""
"添加*cls*，它必须是：class:`sphinx搜索语言`，作为生成HTML全文搜索索引的支持语言。该类必须具有一个*lang*属性，该属性指示该类应用于的语言。请参阅：confval:`html_search_language`。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_source_suffix:1
msgid "Register a suffix of source files."
msgstr "注册源文件的后缀。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_source_suffix:3
msgid ""
"Same as :confval:`source_suffix`.  The users can override this using the "
"setting."
msgstr "同：confval:`source_suffix`。用户可以使用设置覆盖此设置。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_source_suffix:6
msgid ""
"If *override* is True, the given *suffix* is forcedly installed even if a "
"same suffix is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_source_parser:1
msgid "Register a parser class."
msgstr "注册解析器类。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_source_parser:3
msgid ""
"If *override* is True, the given *parser* is forcedly installed even if a "
"parser for the same suffix is already installed."
msgstr ""

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_source_parser:7
msgid ""
"*suffix* argument is deprecated.  It only accepts *parser* argument. Use "
":meth:`add_source_suffix` API to register suffix instead."
msgstr "*后缀*参数已弃用。它只接受*parser*参数。使用：meth:`add_source_suffix`API来注册后缀。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_env_collector:1
msgid "Register an environment collector class."
msgstr "注册环境收集器类。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_env_collector:3
msgid "Refer to :ref:`collector-api`."
msgstr "请参阅：ref:`collector api`。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_html_theme:1
msgid "Register a HTML Theme."
msgstr "注册HTML主题。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_html_theme:3
msgid ""
"The *name* is a name of theme, and *path* is a full path to the theme (refs:"
" :ref:`distribute-your-theme`)."
msgstr "*name*是主题的名称，*path*是主题的完整路径（refs:：ref:`distribute your theme`）。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_html_math_renderer:1
msgid "Register a math renderer for HTML."
msgstr "注册HTML渲染器。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_html_math_renderer:3
msgid ""
"The *name* is a name of math renderer.  Both *inline_renderers* and "
"*block_renderers* are used as visitor functions for the HTML writer: the "
"former for inline math node (``nodes.math``), the latter for block math node"
" (``nodes.math_block``).  Regarding visitor functions, see :meth:`add_node` "
"for details."
msgstr ""
"*name*是数学渲染器的名称。*inline_renderers*和*block_renderers*都用作HTML编写器的访问者函数：前者用于inline"
" math节点(``节点.math``)，后者用于块数学节点(``nodes.math_块``). 关于访问者函数，请参见：meth:`add\\u "
"node`以获取详细信息。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_message_catalog:1
msgid "Register a message catalog."
msgstr "注册邮件目录。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.add_message_catalog:3
msgid ""
"The *catalog* is a name of catalog, and *locale_dir* is a base path of "
"message catalog.  For more details, see "
":func:`sphinx.locale.get_translation()`."
msgstr ""
"*catalog*是catalog的名称，*locale\\u "
"dir*是消息目录的基本路径。有关详细信息，请参见：func:`sphinx.locale.get_翻译()`."

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.is_parallel_allowed:1
msgid "Check parallel processing is allowed or not."
msgstr "检查是否允许并行处理。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.is_parallel_allowed:3
msgid "``typ`` is a type of processing; ``'read'`` or ``'write'``."
msgstr "``typ``是一种处理类型；``读'`或``写'``。"

#: ../../sphinx/doc/extdev/appapi.rst:100
msgid ""
"All these methods raise this exception if something went wrong with the "
"extension API."
msgstr "如果插件接口出现问题，所有这些方法都会引发此异常。"

#: ../../sphinx/doc/extdev/appapi.rst:105
msgid "Emitting events"
msgstr "发射事件"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.emit:1
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.emit_firstresult:1
msgid "Emit *event* and pass *arguments* to the callback functions."
msgstr "发出*事件*并将*参数*传递给回调函数。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.emit:3
msgid ""
"Return the return values of all callbacks as a list.  Do not emit core "
"Sphinx events in extensions!"
msgstr "以列表形式返回所有回调的返回值。不要在扩展中发出核心sphinx事件！"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.emit:8
#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.emit_firstresult:8
msgid "Added *allowed_exceptions* to specify path-through exceptions"
msgstr "添加了*allowed_exceptions*来指定路径穿越异常"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.Sphinx.emit_firstresult:3
msgid "Return the result of the first callback that doesn't return ``None``."
msgstr "返回第一个不返回“None”的回调的结果。"

#: ../../sphinx/doc/extdev/appapi.rst:116
msgid "Sphinx runtime information"
msgstr "Sphinx运行时信息"

#: ../../sphinx/doc/extdev/appapi.rst:118
msgid ""
"The application object also provides runtime information as attributes."
msgstr "应用程序对象还提供运行时信息作为属性。"

#: ../../sphinx/doc/extdev/appapi.rst:122
msgid "Target project.  See :class:`.Project`."
msgstr "目标项目。参见：类：`.项目`。"

#: ../../sphinx/doc/extdev/appapi.rst:126
msgid "Source directory."
msgstr "源目录"

#: ../../sphinx/doc/extdev/appapi.rst:130
msgid "Directory containing ``conf.py``."
msgstr "目录包含``配置文件``."

#: ../../sphinx/doc/extdev/appapi.rst:134
msgid "Directory for storing pickled doctrees."
msgstr "用于存储文档树的目录。"

#: ../../sphinx/doc/extdev/appapi.rst:138
msgid "Directory for storing built document."
msgstr "用于存储生成文档的目录。"

#: ../../sphinx/doc/extdev/appapi.rst:144
msgid "Sphinx core events"
msgstr "Sphinx核心事件"

#: ../../sphinx/doc/extdev/appapi.rst:146
msgid ""
"These events are known to the core.  The arguments shown are given to the "
"registered event handlers.  Use :meth:`.Sphinx.connect` in an extension's "
"``setup`` function (note that ``conf.py`` can also have a ``setup`` "
"function) to connect handlers to the events.  Example:"
msgstr ""
"这些事件是众所周知的。显示的参数将提供给已注册的事件处理程序。用法：meth：`.Sphinx连接`在插件的“setup”函数中（注意``配置文件``也可以有一个“setup”函数来将处理程序连接到事件。例子："

#: ../../sphinx/doc/extdev/appapi.rst:160
msgid ""
"Below is an overview of each event that happens during a build. In the list "
"below, we include the event name, its callback parameters, and the input and"
" output type for that event::"
msgstr "下面是构建期间发生的每个事件的概述。在下面的列表中，我们包括事件名称、其回调参数以及该事件的输入和输出类型："

#: ../../sphinx/doc/extdev/appapi.rst:194
msgid "Here is a more detailed list of these events."
msgstr "下面是这些事件的更详细的列表。"

#: ../../sphinx/doc/extdev/appapi.rst:198
msgid ""
"Emitted when the builder object has been created.  It is available as "
"``app.builder``."
msgstr "创建生成器对象时发出。它可以作为``应用程序生成器``."

#: ../../sphinx/doc/extdev/appapi.rst:203
msgid "Emitted when the config object has been initialized."
msgstr "初始化配置对象时发出。"

#: ../../sphinx/doc/extdev/appapi.rst:209
msgid ""
"Emitted when the environment determines which source files have changed and "
"should be re-read.  *added*, *changed* and *removed* are sets of docnames "
"that the environment has determined.  You can return a list of docnames to "
"re-read in addition to these."
msgstr ""
"当环境确定哪些源文件已更改并应重新读取时发出。*added*、*changed*和*removed*是环境确定的文档名集合。除此之外，您还可以返回要重新读取的文档名列表。"

#: ../../sphinx/doc/extdev/appapi.rst:218
msgid ""
"Emitted when all traces of a source file should be cleaned from the "
"environment, that is, if the source file is removed or before it is freshly "
"read.  This is for extensions that keep their own caches in attributes of "
"the environment."
msgstr "当应该从环境中清除源文件的所有跟踪时（即，如果删除了源文件或在新读取源文件之前）发出。这是针对在环境属性中保留自己缓存的扩展。"

#: ../../sphinx/doc/extdev/appapi.rst:223
msgid ""
"For example, there is a cache of all modules on the environment.  When a "
"source file has been changed, the cache's entries for the file are cleared, "
"since the module declarations could have been removed from the file."
msgstr "例如，环境中有一个所有模块的缓存。当源文件发生更改时，该文件的缓存项将被清除，因为模块声明可能已从文件中删除。"

#: ../../sphinx/doc/extdev/appapi.rst:231
msgid ""
"Emitted after the environment has determined the list of all added and "
"changed files and just before it reads them.  It allows extension authors to"
" reorder the list of docnames (*inplace*) before processing, or add more "
"docnames that Sphinx did not consider changed (but never add any docnames "
"that are not in ``env.found_docs``)."
msgstr ""
"在环境确定了所有添加和更改的文件的列表之后，在环境读取这些文件之前发出。它允许扩展作者在处理之前重新排序文档名（*inplace*），或者添加更多Sphinx认为没有更改的文档名（但绝不添加任何不在``环境发现文件``)."

#: ../../sphinx/doc/extdev/appapi.rst:237
msgid ""
"You can also remove document names; do this with caution since it will make "
"Sphinx treat changed files as unchanged."
msgstr "您还可以删除文档名；请谨慎操作，因为这会使Sphinx将更改后的文件视为未更改的文件。"

#: ../../sphinx/doc/extdev/appapi.rst:244
msgid ""
"Emitted when a source file has been read.  The *source* argument is a list "
"whose single element is the contents of the source file.  You can process "
"the contents and replace this item to implement source-level "
"transformations."
msgstr "读取源文件时发出。*source*参数是一个列表，其单个元素是源文件的内容。您可以处理内容并替换此项来实现源代码级转换。"

#: ../../sphinx/doc/extdev/appapi.rst:248
msgid ""
"For example, if you want to use ``$`` signs to delimit inline math, like in "
"LaTeX, you can use a regular expression to replace ``$...$`` by "
"``:math:`...```."
msgstr "例如，如果要使用“$`”符号来分隔内联数学，就像在LaTeX中一样，可以使用正则表达式将“$…$”替换为“`:math:`…``”。"

#: ../../sphinx/doc/extdev/appapi.rst:256
msgid ""
"Emitted when an object description directive has run.  The *domain* and "
"*objtype* arguments are strings indicating object description of the object."
" And *contentnode* is a content for the object.  It can be modified in-"
"place."
msgstr ""
"在运行对象描述指令时发出。*domain*和*objtype*参数是表示对象的对象描述的字符串。而*contentnode*是对象的内容。可以就地修改。"

#: ../../sphinx/doc/extdev/appapi.rst:264
msgid ""
"Emitted when a doctree has been parsed and read by the environment, and is "
"about to be pickled.  The *doctree* can be modified in-place."
msgstr "当环境解析和读取文档树并将要进行处理时发出。*doctree*可以就地修改。"

#: ../../sphinx/doc/extdev/appapi.rst:269
msgid ""
"Emitted when a cross-reference to an object cannot be resolved. If the event"
" handler can resolve the reference, it should return a new docutils node to "
"be inserted in the document tree in place of the node *node*.  Usually this "
"node is a :class:`reference` node containing *contnode* as a child. If the "
"handler can not resolve the cross-reference, it can either return ``None`` "
"to let other handlers try, or raise :class:`NoUri` to prevent other handlers"
" in trying and suppress a warning about this cross-reference being "
"unresolved."
msgstr ""
"当无法解析对象的交叉引用时发出。如果事件处理程序可以解析引用，它应该返回一个新的docutils节点，以插入到文档树中，而不是node*node*。通常，此节点是一个：class:`reference`节点，其中包含*contnode*作为子节点。如果处理程序无法解析交叉引用，则它可以返回“None”以让其他处理程序尝试，或引发：class:`NoUri`以阻止其他处理程序尝试并禁止显示有关此交叉引用未解析的警告。"

#: ../../sphinx/doc/extdev/appapi.rst:0
msgid "Parameters"
msgstr "参数"

#: ../../sphinx/doc/extdev/appapi.rst:279
msgid "The build environment (``app.builder.env``)."
msgstr "构建环境(``app.builder.env``)."

#: ../../sphinx/doc/extdev/appapi.rst:280
msgid ""
"The :class:`pending_xref` node to be resolved.  Its attributes ``reftype``, "
"``reftarget``, ``modname`` and ``classname`` attributes determine the type "
"and target of the reference."
msgstr ""
"要解析的：class:`pending_xref`节点。它的属性“reftype”、“reftarget”、“modname”和“classname”属性决定了引用的类型和目标。"

#: ../../sphinx/doc/extdev/appapi.rst:283
msgid ""
"The node that carries the text and formatting inside the future reference "
"and should be a child of the returned reference node."
msgstr "在将来引用中承载文本和格式的节点，它应该是返回的引用节点的子节点。"

#: ../../sphinx/doc/extdev/appapi.rst:290
msgid ""
"Emitted when a cross-reference to an object cannot be resolved even after "
":event:`missing-reference`.  If the event handler can emit warnings for the "
"missing reference, it should return ``True``."
msgstr ""

#: ../../sphinx/doc/extdev/appapi.rst:298
msgid ""
"Emitted when a doctree has been \"resolved\" by the environment, that is, "
"all references have been resolved and TOCs have been inserted.  The "
"*doctree* can be modified in place."
msgstr "当环境已“解析”文档树时发出，也就是说，已解析所有引用并插入toc。*doctree*可以就地修改。"

#: ../../sphinx/doc/extdev/appapi.rst:302
msgid ""
"Here is the place to replace custom nodes that don't have visitor methods in"
" the writers, so that they don't cause errors when the writers encounter "
"them."
msgstr "这里是替换编写器中没有用户方法的自定义节点的地方，这样当编写器遇到它们时，它们不会导致错误。"

#: ../../sphinx/doc/extdev/appapi.rst:307
msgid ""
"This event is only emitted when parallel reading of documents is enabled.  "
"It is emitted once for every subprocess that has read some documents."
msgstr "此事件仅在启用文档并行读取时发出。对于读取了一些文档的每个子进程，它都会发出一次。"

#: ../../sphinx/doc/extdev/appapi.rst:310
msgid ""
"You must handle this event in an extension that stores data in the "
"environment in a custom location.  Otherwise the environment in the main "
"process will not be aware of the information stored in the subprocess."
msgstr "必须在将数据存储在环境中的自定义位置的扩展中处理此事件。否则，主进程中的环境将不知道子进程中存储的信息。"

#: ../../sphinx/doc/extdev/appapi.rst:314
msgid ""
"*other* is the environment object from the subprocess, *env* is the "
"environment from the main process.  *docnames* is a set of document names "
"that have been read in the subprocess."
msgstr "*other*是子进程中的环境对象，*env*是主进程中的环境。*docnames*是在子流程中读取的一组文档名称。"

#: ../../sphinx/doc/extdev/appapi.rst:322
msgid ""
"Emitted when the :meth:`update` method of the build environment has "
"completed, that is, the environment and all doctrees are now up-to-date."
msgstr "当生成环境的：meth:`update`方法完成时发出，即环境和所有文档树现在都是最新的。"

#: ../../sphinx/doc/extdev/appapi.rst:325
msgid ""
"You can return an iterable of docnames from the handler.  These documents "
"will then be considered updated, and will be (re-)written during the writing"
" phase."
msgstr "您可以从处理程序返回可迭代的文档名。这些文件将被视为更新，并将在编写阶段（重新）编写。"

#: ../../sphinx/doc/extdev/appapi.rst:331
msgid "The handlers' return value is now used."
msgstr "现在使用处理程序的返回值。"

#: ../../sphinx/doc/extdev/appapi.rst:336
msgid ""
"Emitted when Consistency checks phase.  You can check consistency of "
"metadata for whole of documents."
msgstr "在一致性检查阶段发出。您可以检查整个文档的元数据的一致性。"

#: ../../sphinx/doc/extdev/appapi.rst:341
msgid "As a **experimental** event"
msgstr "作为一个**实验性**事件"

#: ../../sphinx/doc/extdev/appapi.rst:345
msgid ""
"Emitted when the HTML builder is starting to write non-document pages.  You "
"can add pages to write by returning an iterable from this event consisting "
"of ``(pagename, context, templatename)``."
msgstr "当HTML生成器开始编写非文档页面时发出。您可以通过从这个事件返回一个包含“`（页名，环境，模板名）`”的迭代器来添加要写入的页。"

#: ../../sphinx/doc/extdev/appapi.rst:353
msgid ""
"Emitted when the HTML builder has created a context dictionary to render a "
"template with -- this can be used to add custom elements to the context."
msgstr "当HTML生成器创建了用于呈现模板的上下文字典时发出——这可用于向上下文添加自定义元素。"

#: ../../sphinx/doc/extdev/appapi.rst:356
msgid ""
"The *pagename* argument is the canonical name of the page being rendered, "
"that is, without ``.html`` suffix and using slashes as path separators.  The"
" *templatename* is the name of the template to render, this will be "
"``'page.html'`` for all pages from reST documents."
msgstr ""
"*pagename*参数是所呈现页面的规范名称，即不带“.html”后缀并使用斜杠作为路径分隔符。*templatename*是要呈现的模板的名称，它将是“`”页面.html'``表示reST文档中的所有页面。"

#: ../../sphinx/doc/extdev/appapi.rst:361
msgid ""
"The *context* argument is a dictionary of values that are given to the "
"template engine to render the page and can be modified to include custom "
"values.  Keys must be strings."
msgstr "*context*参数是提供给模板引擎以呈现页面的值的字典，可以对其进行修改以包含自定义值。键必须是字符串。"

#: ../../sphinx/doc/extdev/appapi.rst:365
msgid ""
"The *doctree* argument will be a doctree when the page is created from a "
"reST documents; it will be ``None`` when the page is created from an HTML "
"template alone."
msgstr "从reST文档创建页面时，*doctree*参数将是文档树；仅从HTML模板创建页面时，*doctree*参数将为“None”。"

#: ../../sphinx/doc/extdev/appapi.rst:369
msgid ""
"You can return a string from the handler, it will then replace "
"``'page.html'`` as the HTML template for this page."
msgstr "您可以从处理程序返回一个字符串，然后它将替换“`”页面.html“`”作为此页的HTML模板。"

#: ../../sphinx/doc/extdev/appapi.rst:374
msgid "The return value can now specify a template name."
msgstr "返回值现在可以指定模板名称。"

#: ../../sphinx/doc/extdev/appapi.rst:379
msgid ""
"Emitted when a build has finished, before Sphinx exits, usually used for "
"cleanup.  This event is emitted even when the build process raised an "
"exception, given as the *exception* argument.  The exception is reraised in "
"the application after the event handlers have run.  If the build process "
"raised no exception, *exception* will be ``None``.  This allows to customize"
" cleanup actions depending on the exception status."
msgstr ""
"生成完成后，在Sphinx退出之前发出，通常用于清理。即使生成过程引发异常（以*exception*参数指定），也会发出此事件。事件处理程序运行后，将在应用程序中重新初始化异常。如果生成过程没有引发异常，*exception*将为“None”。这允许根据异常状态自定义清理操作。"

#: ../../sphinx/doc/extdev/appapi.rst:390
msgid "Checking the Sphinx version"
msgstr "检查Sphinx版本"

#: ../../sphinx/doc/extdev/appapi.rst:394
msgid "Use this to adapt your extension to API changes in Sphinx."
msgstr "使用此选项可使您的插件适应Sphinx中的接口更改。"

#: ../../sphinx/sphinx/__init__.pydocstring of sphinx.version_info:1
msgid "Version info for better programmatic use."
msgstr "版本信息，以便更好地编程使用。"

#: ../../sphinx/sphinx/__init__.pydocstring of sphinx.version_info:3
msgid ""
"A tuple of five elements; for Sphinx version 1.2.1 beta 3 this would be "
"``(1, 2, 1, 'beta', 3)``. The fourth element can be one of: ``alpha``, "
"``beta``, ``rc``, ``final``. ``final`` always has 0 as the last element."
msgstr ""
"一个由五个元素组成的元组；对于Sphinx版本1.2.1 beta "
"3，这将是`（1，2，1，'beta'，3）``。第四个元素可以是：`alpha``、`beta``、`rc``、`final``之一。``final``始终将0作为最后一个元素。"

#: ../../sphinx/sphinx/__init__.pydocstring of sphinx.version_info:7
msgid "Before version 1.2, check the string ``sphinx.__version__``."
msgstr "在版本1.2之前，请检查字符串“sphinx.\\uuuversion”。"

#: ../../sphinx/doc/extdev/appapi.rst:400
msgid "The Config object"
msgstr "配置对象"

#: ../../sphinx/sphinx/config.pydocstring of sphinx.config.Config:1
msgid "Configuration file abstraction."
msgstr "配置文件抽象。"

#: ../../sphinx/sphinx/config.pydocstring of sphinx.config.Config:3
msgid ""
"The config object makes the values of all config values available as "
"attributes."
msgstr "config对象使所有配置值的值可用作属性。"

#: ../../sphinx/sphinx/config.pydocstring of sphinx.config.Config:6
msgid ""
"It is exposed via the :py:attr:`sphinx.application.Application.config` and "
":py:attr:`sphinx.environment.Environment.config` attributes. For example, to"
" get the value of :confval:`language`, use either ``app.config.language`` or"
" ``env.config.language``."
msgstr ""
"它通过：py:attr:`sphinx.application.Application.config`and:py:attr:`sphinx.environment.Environment.config`属性。例如，要获取值：confval:`language`，请使用``app.config.language应用程序配置语言``或者``环境配置语言``."

#: ../../sphinx/doc/extdev/appapi.rst:410
msgid "The template bridge"
msgstr "模板桥"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.TemplateBridge:1
msgid ""
"This class defines the interface for a \"template bridge\", that is, a class"
" that renders templates given a template name and a context."
msgstr "这个类定义了“模板桥”的接口，也就是说，一个提供了模板名称和上下文的模板的类。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.TemplateBridge.init:1
msgid "Called by the builder to initialize the template system."
msgstr "由生成器调用以初始化模板系统。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.TemplateBridge.init:3
msgid ""
"*builder* is the builder object; you'll probably want to look at the value "
"of ``builder.config.templates_path``."
msgstr "*builder*是builder对象；您可能需要查看``builder.config.templates_path``."

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.TemplateBridge.init:6
msgid ""
"*theme* is a :class:`sphinx.theming.Theme` object or None; in the latter "
"case, *dirs* can be list of fixed directories to look for templates."
msgstr "*主题*是a:类：`phinx.theming.Theme`对象或无；在后一种情况下，*dirs*可以是查找模板的固定目录列表。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.TemplateBridge.newest_template_mtime:1
msgid ""
"Called by the builder to determine if output files are outdated because of "
"template changes.  Return the mtime of the newest template file that was "
"changed.  The default implementation returns ``0``."
msgstr "由生成器调用以确定输出文件是否因模板更改而过期。返回已更改的最新模板文件的m时间。默认实现返回“0”。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.TemplateBridge.render:1
msgid ""
"Called by the builder to render a template given as a filename with a "
"specified context (a Python dictionary)."
msgstr "由生成器调用，以呈现具有指定上下文（Python字典）的文件名形式给定的模板。"

#: ../../sphinx/sphinx/application.pydocstring of
#: sphinx.application.TemplateBridge.render_string:1
msgid ""
"Called by the builder to render a template given as a string with a "
"specified context (a Python dictionary)."
msgstr "由生成器调用以呈现给定为字符串的模板，并具有指定的上下文（Python字典）。"

#: ../../sphinx/doc/extdev/appapi.rst:421
msgid "Exceptions"
msgstr "例外"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.SphinxError:1
msgid "Base class for Sphinx errors."
msgstr "Sphinx错误的基类。"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.SphinxError:3
msgid ""
"This is the base class for \"nice\" exceptions.  When such an exception is "
"raised, Sphinx will abort the build and present the exception category and "
"message to the user."
msgstr "这是“nice”异常的基类。当引发此类异常时，Sphinx将中止构建并向用户显示异常类别和消息。"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.SphinxError:7
msgid ""
"Extensions are encouraged to derive from this exception for their custom "
"errors."
msgstr "鼓励插件从这个异常中派生出自定义错误。"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.SphinxError:10
msgid ""
"Exceptions *not* derived from :exc:`SphinxError` are treated as unexpected "
"and shown to the user with a part of the traceback (and the full traceback "
"saved in a temporary file)."
msgstr "异常*not*派生自：exc:`SphinxError`将被视为意外的，并将回溯的一部分（以及保存在临时文件中的完整回溯）显示给用户。"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.SphinxError:16
msgid ""
"Description of the exception \"category\", used in converting the exception "
"to a string (\"category: message\").  Should be set accordingly in "
"subclasses."
msgstr "异常“category”的描述，用于将异常转换为字符串（“category:message”）。应该在子类中相应地设置。"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.ConfigError:1
msgid "Configuration error."
msgstr "配置错误。"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.ExtensionError:1
msgid "Extension error."
msgstr "插件错误。"

#: ../../sphinx/sphinx/errors.pydocstring of sphinx.errors.ThemeError:1
msgid "Theme error."
msgstr "主题错误。"

#: ../../sphinx/sphinx/errors.pydocstring of
#: sphinx.errors.VersionRequirementError:1
msgid "Incompatible Sphinx version error."
msgstr "不兼容的Sphinx版本错误。"
