# cython: embedsignature=True
from cpython cimport bool
from kivent_core.systems.staticmemgamesystem cimport (StaticMemGameSystem,
    MemComponent)
from kivent_core.memory_handlers.block cimport MemoryBlock
from kivent_core.memory_handlers.zone cimport MemoryZone
from kivent_core.memory_handlers.indexing cimport IndexedMemoryZone
from kivy.factory import Factory
from kivy.properties import (ObjectProperty, NumericProperty, ListProperty, 
    BooleanProperty, StringProperty)
from kivent_core.entity cimport Entity

from libc.math cimport trunc, sin, cos, fmin, fmax
from kivent_core.systems.rotate_systems cimport RotateStruct2D
from kivent_core.systems.position_systems cimport PositionStruct2D
from kivent_particles.particle cimport ParticleSystem
try:
    import cPickle as pickle
except: 
    import pickle
from os import path

include "particle_config.pxi"
include "particle_math.pxi"

cdef class ParticleEmitter:
    '''The ParticleEmitter class controls the creation of particles for any 
    particular effect. You should not create one directly but instead allow
    EmitterSystem to create them for you. Up to a max of MAX_EMITTERS as 
    defined in particle_config.pxi can be attached to a single entity.

    **Attributes:**
        **effect_name** (str): The name of this effect, as loaded by 
        EmitterSystem.load_effect or EmitterSystem.load_effect_from_data.

        **texture** (str): The name of the texture being used for this particle 
        as registered in resource_managers.TextureManager.

        **pos_offset** (tuple): The (x, y) offset this Emitter should be from 
        the parent Entity's position component. This property returns a copy 
        of the data, not the data itself. Do not modify returned values 
        directly, instead set pos_offset again.

        **x_offset** (float): The x component of pos_offset.

        **y_offset** (float): The y component of pos_offset.

        **emit_angle_offset** (float): The offset in degrees from the parent
        Entity's rotate component.

        **emit_angle_variance** (float): The amount of variance in the angle 
        offset of a particle.

        **life_span** (float): The number of seconds a particle should exist 
        for.

        **life_span_variance** (float): The amount of variance in life_span 
        for an individual particle.

        **paused** (bool): If True this emitter will not create new particles.

        **emitter_type** (int): The type of the emitter. Should be 0 for 
        gravity emitter, and 1 for radial emitter.

        **number_of_particles** (int): The number of particles this effect 
        should create. 

        **gravity** (tuple): The amount of gravity that will effect particles 
        if emitter_type is 0 (Gravity Emitter). This property returns a copy 
        of the data, not the data itself. Do not modify returned values 
        directly, instead set gravity again.

        **gravity_x** (float): The x component of gravity.

        **gravity_y** (float): The y component of gravity.

        **start_scale** (float): The scaling factor for the particles at the 
        beginning of their life. Actual size of particle will be scale * size
        of texture.

        **start_scale_variance** (float): The amount of variance in start_scale 
        for an individual particle.

        **end_scale** (float): The scaling factor for the particles at the 
        end of their life. Actual size of particle will be scale * size of 
        texture.

        **end_scale_variance** (float): The amount of variance in end_scale 
        for an individual particle.

        **start_rotation** (float): The starting rotation for a particle in 
        degrees.

        **start_rotation_variance** (float): The variance in starting rotation
        for individual particles.

        **end_rotation** (float): The ending rotation for a particle in 
        degrees. 

        **end_rotation_variance** (float): The variance in ending rotation 
        for individual particles.

        **pos_variance** (tuple): The amount of variance from the location of 
        emitter per particle. This property returns a copy 
        of the data, not the data itself. Do not modify returned values 
        directly, instead set pos_variance again.

        **x_variance** (float): The x component of pos_variance.

        **y_variance** (float): The y component of pos_variance.

        **speed** (float): The speed a particle will be emitted at if the 
        emitter_type is 0 (Gravity emitter).

        **speed_variance** (float): The variance in speed for particles
        generated by emitter_type 0 (Gravity emitter).

        **radial_acceleration** (float): The amount of radial acceleration 
        to be applied to particles generated by emitter_type 0 
        (Gravity emitters).

        **radial_acceleration_variance** (float): The variation in 
        radial_acceleration.

        **tangential_acceleration** (float): The amount of tangential
        acceleration to be applied to particles generated by emitter_type 0 
        (Gravity emitters).

        **tangential_acceleration_variance** (float): The variation in 
        tangential_acceleration.

        **max_radius** (float): The starting distance for particles being
        emitted by emitter_type 1 (radial emitters).

        **max_radius_variance** (float): The variance in starting distance
        for radial emitters.

        **min_radius** (float): The minimum radius before a particle is 
        cleaned up when emitted by emitter_type 1 (radial emitters).

        **rotate_per_second** (float): The amount of rotation in degrees 
        that will happen per second for particles emitted by emitter_type 1
        (radial emitters).

        **rotate_per_second_variance** (float): The variation in
        rotate_per_second.

        **start_color** (list): The starting color for particles. This property 
        returns a copy of the data, not the data itself. Do not modify returned
        values directly, instead set start_color again.

        **start_color_variance** (list): The amount of variance in each channel
        for the starting color of particles. This property 
        returns a copy of the data, not the data itself. Do not modify returned
        values directly, instead set start_color_variance again.

        **end_color** (list): The ending color for particles. This property 
        returns a copy of the data, not the data itself. Do not modify returned
        values directly, instead set end_color again.

        **end_color_variance** (list): The amount of variance in each channel
        for the ending color of particles. This property 
        returns a copy of the data, not the data itself. Do not modify returned
        values directly, instead set end_color_variance again.

    '''

    def __cinit__(self, str effect_name):
        self._effect_name = effect_name
        self._emit_angle_offset = 0.0
        self._emit_angle = 0.
        self._life_span = 1.0
        self._paused = False
        self._emitter_type = 0
        self._number_of_particles = 0
        self._current_particles = 0
        self._emission_rate = 1.0
        self._frame_time = 0.0
        self._start_scale = 1.
        self._start_scale_variance = 0.0
        self._end_scale = 0.0
        self._end_scale_variance = 0.0
        self._emit_angle_variance = 0.0
        self._start_rotation = 0.0
        self._start_rotation_variance = 0.0
        self._end_rotation = 0.0
        self._end_rotation_variance = 0.0
        self._life_span_variance = 0.0
        self._speed = 10.0
        self._speed_variance = 0.0
        self._radial_acceleration = 0.0
        self._radial_acceleration_variance = 0.0
        self._tangential_acceleration = 0.0
        self._tangential_acceleration_variance = 0.0
        self._max_radius = 25.0
        self._max_radius_variance = 0.0
        self._min_radius = 0.0
        self._rotate_per_second = 0.0
        self._texture = None
        self._rotate_per_second_variance = 0.0
        self.active_particles = set()
        cdef int x
        for x in range(2):
            self._gravity[x] = 0.           
            self._pos_variance[x] = 0.
            self._pos_offset[x] = 0.
            self._pos[x] = 0.
        for x in range(4):
            self._start_color[x] = 255
            self._start_color_variance[x] = 0
            self._end_color[x] = 255
            self._end_color_variance[x] = 0

    def calculate_emission_rate(self):
        '''
        This is called automatically when either number_of_particles or 
        life_span is set. Emission rate is calculated by dividing the 
        number_of_particles by the life_span.
        '''
        if self._life_span <= 0.001:
            self._emission_rate = 0.
        else:
            self._emission_rate = float(
                self._number_of_particles) / self._life_span

    property pos:
        def __get__(self):
            return (self._pos[0], self._pos[1])

    property texture:

        def __get__(self):
            return self._texture

        def __set__(self, str name):
            self._texture = name

    property effect_name:

        def __get__(self):
            return self._effect_name

        def __set__(self, str name):
            self._effect_name = name

    property x_offset:

        def __get__(self):
            return self._pos_offset[0]

        def __set__(self, float value):
            self._pos_offset[0] = value

    property y_offset:
        def __get__(self):
            return self._pos_offset[1]

        def __set__(self, float value):
            self._pos_offset[1] = value

    property pos_offset:

        def __get__(self):
            return [self._pos_offset[i] for i in range(2)]

        def __set__(self, value):
            for i in range(2):
                self._pos_offset[i] = value[i]

    property emit_angle_offset:

        def __get__(self):
            return cy_degrees(self._emit_angle_offset)

        def __set__(self, float value):
            self._emit_angle_offset = cy_radians(value)

    property life_span:

        def __get__(self):
            return self._life_span

        def __set__(self, float value):
            self._life_span = value
            self.calculate_emission_rate()

    property paused:

        def __get__(self):
            return self._paused

        def __set__(self, value):
            self._paused = value

    property emitter_type:

        def __get__(self):
            return self._emitter_type

        def __set__(self, value):
            self._emitter_type = value

    property number_of_particles:

        def __get__(self):
            return self._number_of_particles

        def __set__(self, value):
            self._number_of_particles = value
            self.calculate_emission_rate()

    property life_span_variance:

        def __get__(self):
            return self._life_span_variance

        def __set__(self, value):
            self._life_span_variance = value

    property gravity_x:

        def __get__(self):
            return self._gravity[0]

        def __set__(self, value):
            self._gravity[0] = value

    property gravity_y:

        def __get__(self):
            return self._gravity[1]

        def __set__(self, value):
            self._gravity[1] = value

    property gravity:

        def __get__(self):
            return [self._gravity[i] for i in range(2)]

        def __set__(self, value):
            for i in range(2):
                self._gravity[i] = value[i]

    property start_scale:

        def __get__(self):
            return self._start_scale

        def __set__(self, value):
            self._start_scale = value

    property start_scale_variance:

        def __get__(self):
            return self._start_scale_variance

        def __set__(self, value):
            self._start_scale_variance = value

    property end_scale:

        def __get__(self):
            return self._end_scale

        def __set__(self, value):
            self._end_scale = value

    property end_scale_variance:

        def __get__(self):
            return self._end_scale_variance

        def __set__(self, value):
            self._end_scale_variance = value

    property emit_angle_variance:

        def __get__(self):
            return cy_degrees(self._emit_angle_variance)

        def __set__(self, value):
            self._emit_angle_variance = cy_radians(value)

    property start_rotation:

        def __get__(self):
            return cy_degrees(self._start_rotation)

        def __set__(self, value):
            self._start_rotation = cy_radians(value)

    property start_rotation_variance:

        def __get__(self):
            return cy_degrees(self._start_rotation_variance)

        def __set__(self, value):
            self._start_rotation_variance = cy_radians(value)

    property end_rotation:

        def __get__(self):
            return cy_degrees(self._end_rotation)

        def __set__(self, value):
            self._end_rotation = cy_radians(value)

    property end_rotation_variance:

        def __get__(self):
            return cy_degrees(self._end_rotation_variance)

        def __set__(self, value):
            self._end_rotation_variance = cy_radians(value)

    property x_variance:

        def __get__(self):
            return self._pos_variance[0]

        def __set__(self, value):
            self._pos_variance[0] = value

    property y_variance:

        def __get__(self):
            return self._pos_variance[1]

        def __set__(self, value):
            self._pos_variance[1] = value

    property pos_variance:

        def __get__(self):
            return [self._pos_variance[i] for i in range(2)]

        def __set__(self, value):
            for i in range(2):
                self._pos_variance[i] = value[i]

    property speed:

        def __get__(self):
            return self._speed

        def __set__(self, value):
            self._speed = value

    property speed_variance:

        def __get__(self):
            return self._speed_variance

        def __set__(self, value):
            self._speed_variance = value

    property radial_acceleration:

        def __get__(self):
            return self._radial_acceleration

        def __set__(self, value):
            self._radial_acceleration = value

    property radial_acceleration_variance:

        def __get__(self):
            return self._radial_acceleration_variance

        def __set__(self, value):
            self._radial_acceleration_variance = value

    property tangential_acceleration:

        def __get__(self):
            return self._tangential_acceleration

        def __set__(self, value):
            self._tangential_acceleration = value

    property tangential_acceleration_variance:

        def __get__(self):
            return self._tangential_acceleration_variance

        def __set__(self, value):
            self._tangential_acceleration_variance = value

    property max_radius:

        def __get__(self):
            return self._max_radius

        def __set__(self, value):
            self._max_radius = value

    property max_radius_variance:

        def __get__(self):
            return self._max_radius_variance

        def __set__(self, value):
            self._max_radius_variance = value

    property min_radius:

        def __get__(self):
            return self._min_radius

        def __set__(self, value):
            self._min_radius = value

    property rotate_per_second:

        def __get__(self):
            return cy_degrees(self._rotate_per_second)

        def __set__(self, value):
            self._rotate_per_second = cy_radians(value)

    property rotate_per_second_variance:

        def __get__(self):
            return cy_degrees(self._rotate_per_second_variance)

        def __set__(self, value):
            self._rotate_per_second_variance = cy_radians(value)

    property start_color:

        def __get__(self):
            return [self._start_color[x] for x in range(4)]

        def __set__(self, value):
            for i in range(4):
                self._start_color[i] = value[i]

    property start_color_variance:

        def __get__(self):
            return [self._start_color_variance[x] for x in range(4)]

        def __set__(self, value):
            for i in range(4):
                self._start_color_variance[i] = value[i]

    property end_color:

        def __get__(self):
            return [self._end_color[x] for x in range(4)]

        def __set__(self, value):
            for i in range(4):
                self._end_color[i] = value[i]

    property end_color_variance:

        def __get__(self):
            return [self._end_color_variance[x] for x in range(4)]

        def __set__(self, value):
            for i in range(4):
                self._end_color_variance[i] = value[i]


cdef class EmitterComponent(MemComponent):
    '''The component associated with EmitterSystem. Do not modify **emitters**
    yourself. Prefer to use EmitterSystem.add_effect and remove_effect.

    **Attributes:**
        **entity_id** (unsigned int): The entity_id this component is currently
        associated with. Will be <unsigned int>-1 if the component is 
        unattached.

        **emitters** (list): List of length MAX_EMITTERS (defaults to 8, you 
        can change this by recompiling kivent_particles after 
        modifying particle_config.pxi). Any active emitters will be in this
        list, open spots will be None.
    '''
    def __cinit__(self, MemoryBlock memory_block, unsigned int index,
            unsigned int offset):
        self._emitters = [None for x in range(MAX_EMITTERS)]

    
    property entity_id:

        def __get__(self):
            cdef EmitterStruct* data = <EmitterStruct*>self.pointer
            return data.entity_id

    property emitters:

        def __get__(self):
            return self._emitters


class TooManyEmitters(Exception):
    pass

cdef class EmitterSystem(StaticMemGameSystem):
    '''
    Processing Depends On: EmitterSystem, PositionSystem2D, RotateSystem2D

    The EmitterSystem manages attaching particle effects to entities. Each 
    Entity can have up to particle_config.MAX_EMITTERS emitters attached at 
    once. This defaults to 8. If you wish to have more emitters, change this
    value in particle_config.pxi and recompile kivent_particles.

    You need to load an emitter before attaching it to an Entity. This can be 
    done either through providing a dictionary of properties, using 
    load_effect_from_data, or loading a .kep file, using load_effect. Emitters 
    can then be added during init_entity by including the name of the effects 
    to attach, or by calling add_effect.

    This GameSystem will use the entities PositionSystem2D and RotateSystem2D
    components to influence the location of particles.

    **Attributes:**
        **loaded_effects** (list): Returns a list of the names for each effect 
        that has been loaded.

        **particle_system** (ObjectProperty): Reference to the ParticleSystem 
        that will handle the creation and update of individual particles for
        the emitters of this system. Typically you will link this in your .kv 
        file.
    '''
    system_id = StringProperty('emitters')
    type_size = NumericProperty(sizeof(EmitterStruct))
    component_type = ObjectProperty(EmitterComponent)
    updateable = BooleanProperty(True)
    processor = BooleanProperty(True)
    system_names = ListProperty(['emitters', 'position', 'rotate'])
    particle_system = ObjectProperty(None)    

    def __init__(self, **kwargs):
        super(EmitterSystem, self).__init__(**kwargs)
        self._emitter_prototypes = {}
        self.attributes_to_save = ['effect_name', 'pos_offset',
            'emit_angle_offset', 'gravity', 'pos_variance', 'life_span', 
            'paused', 'emitter_type', 'number_of_particles', 
            'life_span_variance', 'start_scale', 'start_scale_variance', 
            'end_scale', 'end_scale_variance', 'emit_angle_variance', 
            'start_rotation', 'start_rotation_variance', 'end_rotation', 
            'end_rotation_variance',
            'speed', 'speed_variance', 'radial_acceleration', 
            'radial_acceleration_variance', 'tangential_acceleration', 
            'tangential_acceleration_variance', 'max_radius', 'min_radius',
            'max_radius_variance', 'rotate_per_second', 
            'rotate_per_second_variance', 'start_color', 'start_color_variance',
            'end_color', 'end_color_variance', 'texture']
        self.editor_type = 'subobject'
        self.subobject_field = 'emitters'
        self.subobject_name_field = 'effect_name'
        self.editor_fields = {
            'pos_offset': {'count': 2, 'type': 'slider', 'step': 1.,
                'name': 'Pos Offset', 'value_names': ['x', 'y'],
                'bounds': [(-1000., 1000.), (-1000., 1000.)]},
            'emitter_type': {'type': 'choice', 'name': 'Emitter Type',
                'choices': [('Gravity', 0), ('Radial', 1)], },
            'gravity': {'count': 2, 'type': 'slider', 'step': 1.0,
                'name': 'Gravity', 'value_names': ['x', 'y'],
                'bounds': [(-250., 250.), (-250., 250.)]},
            'emit_angle_offset': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Emit Angle Offset',
                'bounds': [(-360., 360.)]},
            'pos_variance': {'count': 2, 'type': 'slider', 'step': 1.,
                'name': 'Pos Variance', 'value_names': ['x', 'y'],
                'bounds': [(0., 1000.), (0., 1000.)]},
            'life_span': {'count': 1, 'type': 'slider', 'step': .05,
                'name': 'Lifespan',
                'bounds': [(0., 20.)]},
            'number_of_particles': {'count': 1, 'type': 'slider', 'step': 1,
                'name': 'Number of Particles',
                'bounds': [(1, 2500)]},
            'life_span_variance': {'count': 1, 'type': 'slider', 'step': .25,
                'name': 'Life Span Variance',
                'bounds': [(0., 20.)]},
            'start_scale': {'count': 1, 'type': 'slider', 'step': .01,
                'name': 'Start Scale',
                'bounds': [(0., 5.)]},
            'start_scale_variance': {'count': 1, 'type': 'slider', 'step': .01,
                'name': 'Start Scale Variance',
                'bounds': [(0., 5.)]},
            'end_scale': {'count': 1, 'type': 'slider', 'step': .01,
                'name': 'End Scale',
                'bounds': [(0., 5.)]},
            'end_scale_variance': {'count': 1, 'type': 'slider', 'step': .01,
                'name': 'End Scale Variance',
                'bounds': [(0., 5.)]},
            'emit_angle_variance': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Emit Angle Variance',
                'bounds': [(0., 360.)]},
            'start_rotation': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Start Rotation',
                'bounds': [(-360., 360.)]},
            'start_rotation_variance': {'count': 1, 'type': 'slider', 
                'step': 1.,
                'name': 'Start Rotation Variance',
                'bounds': [(0., 360.)]},
            'end_rotation': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'End Rotation',
                'bounds': [(-360., 360.)]},
            'end_rotation_variance': {'count': 1, 'type': 'slider', 
                'step': 1.,
                'name': 'End Rotation Variance',
                'bounds': [(0, 360.)]},
            'speed': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Speed',
                'bounds': [(0., 1000.)]},
            'speed_variance': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Speed Variance',
                'bounds': [(0., 1000.)]},
            'radial_acceleration': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Radial Acceleration',
                'bounds': [(-400., 400.)]},
            'radial_acceleration_variance': {'count': 1, 'type': 'slider',
                'step': 1.,
                'name': 'Radial Acceleration Variance',
                'bounds': [(0., 400.)]},
            'tangential_acceleration': {'count': 1, 'type': 'slider',
                'step': 1.,
                'name': 'Tangential Acceleration',
                'bounds': [(-500., 500.)]},
            'tangential_acceleration_variance': {'count': 1, 'type': 'slider',
                'step': 1.,
                'name': 'Tangential Acceleration Variance',
                'bounds': [(0., 500.)]},
            'max_radius': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Max Radius',
                'bounds': [(0., 250.)]},
            'min_radius': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Min Radius',
                'bounds': [(0., 250.)]},
            'max_radius_variance': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Max Radius Variance',
                'bounds': [(0., 250.)]},
            'rotate_per_second': {'count': 1, 'type': 'slider', 'step': 1.,
                'name': 'Rotate Per Second',
                'bounds': [(-720., 720.)]},
            'rotate_per_second_variance': {'count': 1, 'type': 'slider',
                'step': 1.,
                'name': 'Rotate Per Second Variance',
                'bounds': [(0., 720.)]},
            'start_color': {'count': 4, 'type': 'slider', 'step': 1,
                'name': 'Start Color', 'value_names': ['r', 'g', 'b', 'a'],
                'bounds': [(0, 255), (0, 255), (0, 255), (0, 255)]},
            'start_color_variance': {'count': 4, 'type': 'slider', 'step': 1,
                'name': 'Start Color Variance', 
                'value_names': ['r', 'g', 'b', 'a'],
                'bounds': [(0, 255), (0, 255), (0, 255), (0, 255)]},
            'end_color': {'count': 4, 'type': 'slider', 'step': 1,
                'name': 'End Color', 'value_names': ['r', 'g', 'b', 'a'],
                'bounds': [(0, 255), (0, 255), (0, 255), (0, 255)]},
            'end_color_variance': {'count': 4, 'type': 'slider', 'step': 1,
                'name': 'End Color Variance', 
                'value_names': ['r', 'g', 'b', 'a'],
                'bounds': [(0, 255), (0, 255), (0, 255), (0, 255)]},
            }
        self.panels = {
            'panel_order': ['general', 'gravity', 'radial', 'color'],
            'general': {
                'name': 'General',
                'fields': [
                    'emitter_type', 'pos_offset', 
                    'emit_angle_offset', 'emit_angle_variance', 'life_span', 
                    'life_span_variance', 'number_of_particles', 'start_scale', 
                    'start_scale_variance', 'end_scale', 'end_scale_variance',
                    'start_rotation', 'start_rotation_variance', 'end_rotation',
                    'end_rotation_variance',
                    ],
                },
            'gravity': {
                'name': 'Gravity Emitter',
                'fields': [
                    'pos_variance',
                    'gravity', 'radial_acceleration', 
                    'radial_acceleration_variance', 'tangential_acceleration',
                    'tangential_acceleration_variance', 'speed',
                    'speed_variance',
                    ],
                },
            'radial': {
                'name': 'Radial Emitter',
                'fields': [
                    'max_radius', 'max_radius_variance', 'min_radius',
                    'rotate_per_second', 'rotate_per_second_variance'
                    ],
                },
            'color': {
                'name': 'Effect Color',
                'fields': [
                    'start_color', 'start_color_variance', 'end_color',
                    'end_color_variance',
                    ],
                },
            }

    property editor_fields:

        def __get__(self):
            return self.editor_fields

    property panels:

        def __get__(self):
            return self.panels

    property editor_type:

        def __get__(self):
            return self.editor_type

    property subobject_field:

        def __get__(self):
            return self.subobject_field

    property subobject_name_field:

        def __get__(self):
            return self.subobject_name_field

    property loaded_effects:

        def __get__(self):
            return [x for x in self._emitter_prototypes]
        
    def init_component(self, unsigned int component_index, 
        unsigned int entity_id, str zone, args):
        '''
        Args:

            args (list): List of effect names to load, effect_name must be 
            in **loaded_effects**. 

        The initialization arguments for an Emitter component is a list of 
        the names of previously loaded effects to attach to your entity.
        '''
        cdef EmitterComponent py_component = self.components[component_index]
        cdef EmitterStruct* component = <EmitterStruct*>py_component.pointer
        cdef ParticleEmitter emitter
        component.entity_id = entity_id
        cdef unsigned int ent_comps_ind = self.entity_components.add_entity(
            entity_id, zone)
        cdef void** component_data = <void**>(
            self.entity_components.memory_block.data)
        cdef unsigned int component_count = self.entity_components.count
        cdef unsigned int real_index = ent_comps_ind * component_count
        cdef PositionStruct2D* pos_comp = <PositionStruct2D*>component_data[
            real_index+1]
        cdef RotateStruct2D* rot_comp = <RotateStruct2D*>component_data[
            real_index+2]
        cdef float[2] resulting_offset

        for effect_name in args:
            emitter = self.create_effect(effect_name)
            index = self.insert_effect_into_component(emitter, py_component)
            emitter._emit_angle = rot_comp.r + emitter._emit_angle_offset
            rotate_offset(emitter._pos_offset, emitter._emit_angle, 
                resulting_offset)
            emitter._pos[0] = pos_comp.x + resulting_offset[0]
            emitter._pos[1] = pos_comp.y + resulting_offset[1]

    def update(self, float dt):
        cdef void** component_data = <void**>(
            self.entity_components.memory_block.data)
        cdef unsigned int component_count = self.entity_components.count
        cdef unsigned int count = self.entity_components.memory_block.count
        cdef unsigned int i, real_index, e, o, c

        cdef EmitterStruct* emitter_comp
        cdef PositionStruct2D* pos_comp
        cdef RotateStruct2D* rot_comp
        cdef ParticleEmitter emitter

        cdef float angle_offset, time_between_particles
        cdef float[2] resulting_offset
        cdef int number_of_updates
        cdef set active_particles
        cdef ParticleSystem particle_system = self.particle_system
        cdef unsigned int particle_id
        for i in range(count):
            real_index = i*component_count
            if component_data[real_index] == NULL:
                continue
            emitter_comp = <EmitterStruct*>component_data[real_index]
            pos_comp = <PositionStruct2D*>component_data[real_index+1]
            rot_comp = <RotateStruct2D*>component_data[real_index+2]
            ecount = 0
            for e in range(MAX_EMITTERS):
                if emitter_comp.emitters[e] is NULL:
                    continue
                ecount += 1
                emitter = <ParticleEmitter>emitter_comp.emitters[e]
                if not emitter._paused:
                    emitter._emit_angle = (
                        rot_comp.r + emitter._emit_angle_offset
                        )
                    rotate_offset(emitter._pos_offset, 
                        emitter._emit_angle, 
                        resulting_offset)
                    emitter._pos[0] = pos_comp.x + resulting_offset[0]
                    emitter._pos[1] = pos_comp.y + resulting_offset[1]
                    if emitter._emission_rate <= 0.0:
                        number_of_updates = 0
                    else:
                        emitter._frame_time += dt
                        time_between_particles = 1.0 / emitter._emission_rate
                        number_of_updates = <int>(
                            emitter._frame_time / time_between_particles)
                        emitter._frame_time -= (
                            time_between_particles * number_of_updates)
                    active_particles = emitter.active_particles
                    for c in range(number_of_updates):
                        particle_id = particle_system.create_particle(emitter)
                        active_particles.add(particle_id)


    def flatten_effect_to_dict(self, ParticleEmitter emitter):
        '''
        Args:

            emitter (ParticleEmitter): The emitter to write out.

        Takes a ParticleEmitter object and returns a dictionary containing 
        property, value pairs. Used internally as part of saving an effect.
        '''
        data = {}
        for key in self.attributes_to_save:
            data[key] = getattr(emitter, key)
        return data

    def pickle_effect(self, ParticleEmitter emitter, str file_name):
        '''
        Args:

            emitter (ParticleEmitter): The emitter to pickle.

            file_name (str): The name of the file to write.

        Uses cPickle to save an emitter to disk.
        '''
        effect_data = self.flatten_effect_to_dict(emitter)
        output = open(file_name, 'wb')
        pickle.dump(effect_data, output)
        output.close()

    def load_effect(self, str file_name):
        '''
        Args:

            file_name (str): Name of the file to load.

        Return:
            str: The name of the effect as it was loaded into memory.

        Loads a previously saved effect, uses cPickle. The name of the effect 
        will be returned.
        '''
        effect_name = path.splitext(path.basename(file_name))[0]
        input_f = open(file_name, 'rb')
        data = pickle.load(input_f)
        input_f.close()
        self.load_effect_from_data(data, effect_name)
        return effect_name
        
    def load_effect_from_data(self, dict data, str effect_name):
        '''
        Args:

            data (dict): Dict containing ParticleEmitter property name, value 
            pairs. Can contain all or a subset of the ParticleEmitter
            properties.

            effect_name (str): Name of the new effect.

        Loads an effect into memory from a dictionary.
        '''
        cdef ParticleEmitter emitter = ParticleEmitter(effect_name)
        for key in data:
            setattr(emitter, key, data[key])
        self._emitter_prototypes[effect_name] = emitter

    def create_effect(self, str effect_name):
        '''
        Args:

            effect_name (str): Name of the loaded effect from which the new 
            Emitter will copy its starting data.

        Return:

            ParticleEmitter: The new emitter.

        Typically called internally as part of the init_component or 
        add_effect functions, this function returns a new ParticleEmitter 
        object that copies the state of the ParticleEmitter loaded under 
        effect_name using either load_effect or load_effect_from_data.
        '''
        cdef ParticleEmitter prototype = self._emitter_prototypes[effect_name]
        cdef ParticleEmitter new_effect = ParticleEmitter(effect_name)
        self.copy_effect(prototype, new_effect)
        return new_effect

    def copy_data_into_emitter(self, ParticleEmitter to_emitter, 
        str effect_name):
        '''
        Args:

            to_emitter (ParticleEmitter): Emitter to copy the state of the 
            effect into.

            effect_name (str): Name of the loaded effect you want to copy 
            the state of.

        This function will efficiently copy the prototype loaded under 
        effect_name into the provided ParticleEmitter.
        '''
        cdef ParticleEmitter from_emitter = self._emitter_prototypes[
            effect_name]
        self.copy_effect(from_emitter, to_emitter)

    cdef void copy_effect(self, ParticleEmitter from_emitter, 
        ParticleEmitter to_emitter):
        cdef int i 
        to_emitter._emit_angle_offset = from_emitter._emit_angle_offset
        to_emitter._texture = from_emitter._texture
        cdef float[2] _pos_offset
        for i in range(2):
            to_emitter._pos_offset[i] = from_emitter._pos_offset[i]
            to_emitter._gravity[i] = from_emitter._gravity[i]
            to_emitter._pos_variance[i] = from_emitter._pos_variance[i]
        to_emitter._life_span = from_emitter._life_span
        to_emitter._paused = from_emitter._paused
        to_emitter._emitter_type = from_emitter._emitter_type
        to_emitter._number_of_particles = from_emitter._number_of_particles
        to_emitter._frame_time = from_emitter._frame_time
        to_emitter._start_scale = from_emitter._start_scale
        to_emitter._emission_rate = from_emitter._emission_rate
        to_emitter._start_scale_variance = from_emitter._start_scale_variance
        to_emitter._end_scale = from_emitter._end_scale
        to_emitter._end_scale_variance = from_emitter._end_scale_variance
        to_emitter._emit_angle_variance = from_emitter._emit_angle_variance
        to_emitter._start_rotation = from_emitter._start_rotation
        to_emitter._start_rotation_variance = (
            from_emitter._start_rotation_variance)
        to_emitter._end_rotation = from_emitter._end_rotation
        to_emitter._end_rotation_variance = from_emitter._end_rotation_variance
        to_emitter._life_span_variance = from_emitter._life_span_variance
        to_emitter._speed = from_emitter._speed
        to_emitter._speed_variance = from_emitter._speed_variance
        to_emitter._radial_acceleration = from_emitter._radial_acceleration
        to_emitter._radial_acceleration_variance = (
            from_emitter._radial_acceleration_variance)
        to_emitter._tangential_acceleration = (
            from_emitter._tangential_acceleration)
        to_emitter._tangential_acceleration_variance = (
            from_emitter._tangential_acceleration_variance)
        to_emitter._max_radius = from_emitter._max_radius
        to_emitter._max_radius_variance = from_emitter._max_radius_variance
        to_emitter._min_radius = from_emitter._min_radius
        to_emitter._rotate_per_second = from_emitter._rotate_per_second
        to_emitter._rotate_per_second_variance = (
            from_emitter._rotate_per_second_variance)
        for i in range(4):
            to_emitter._start_color[i] = from_emitter._start_color[i]
            to_emitter._start_color_variance[i] = (
                from_emitter._start_color_variance[i])
            to_emitter._end_color[i] = from_emitter._end_color[i]
            to_emitter._end_color_variance[i] = (
                from_emitter._end_color_variance[i])

    cdef int insert_effect_into_component(self, ParticleEmitter effect, 
        EmitterComponent py_component) except -1:
        cdef list emitters = py_component._emitters
        cdef EmitterStruct* pointer = <EmitterStruct*>py_component.pointer
        cdef int i
        used = 0
        for i in range(MAX_EMITTERS):
            if pointer.emitters[i] is NULL:
                pointer.emitters[i] = <void*>effect
                emitters[i] = effect
                used = i
                break
        else:
            raise TooManyEmitters('Change MAX_EMITTERS in'
                'particles_config.pxi to have more emitters per entity or'
                'use less emitters')
        return used

    def add_effect(self, unsigned int entity_id, str effect_name):
        '''
        Args:

            entity_id (unsigned int): Id of the entity to add the effect to.

            effect_name (str): Name of the effect to add.

        Return:

            int: returns the index in the emitters list for the
            EmitterComponent of the new effect.

        This function will create a new effect for your entity that already 
        have an EmitterComponent. If MAX_EMITTERS is exceeded a TooManyEmitters
        exception will be raised.
        '''
        cdef IndexedMemoryZone components = self.imz_components
        cdef IndexedMemoryZone entities = self.gameworld.entities
        cdef Entity entity = entities[entity_id]
        cdef unsigned int component_index = entity.get_component_index(
            self.system_id)
        cdef EmitterComponent py_component = self.components[component_index]
        return self.insert_effect_into_component(
            self.create_effect(effect_name), py_component)

    def remove_effect(self, unsigned int entity_id, int index):
        '''
        Args:

            entity_id (unsigned int): Id of the entity to remove the effect 
            from.

            index (int): Index of the emitter to be removed in the Entity's
            EmitterComponent emitters list.

        Removes an effect from an existing entity without destroying the whole
        component.
        '''
        cdef IndexedMemoryZone components = self.imz_components
        cdef IndexedMemoryZone entities = self.gameworld.entities
        cdef Entity entity = entities[entity_id]
        cdef unsigned int component_index = entity.get_component_index(
            self.system_id)
        cdef EmitterComponent py_component = self.components[component_index]
        cdef ParticleEmitter emitter = py_component._emitters[index]
        entities_to_remove = [x for x in emitter.active_particles]
        py_component._emitters[index] = None
        remove_entity = self.gameworld.remove_entity
        for each in entities_to_remove:
            remove_entity(each)
        cdef EmitterStruct* pointer = <EmitterStruct*>py_component.pointer
        pointer.emitters[index] = NULL


    def clear_component(self, unsigned int component_index):
        cdef MemoryZone memory_zone = self.imz_components.memory_zone
        cdef EmitterStruct* pointer = <EmitterStruct*>(
            memory_zone.get_pointer(component_index))
        cdef EmitterComponent py_component = self.components[component_index]
        cdef ParticleEmitter emitter
        for index, emitter in enumerate(py_component._emitters):
            if emitter is not None:
                self.remove_effect(pointer.entity_id, index)
        pointer.entity_id = -1
        cdef int i

        for i in range(MAX_EMITTERS):
            pointer.emitters[i] = NULL
        py_component._emitters = [None for x in range(MAX_EMITTERS)]


    def remove_component(self, unsigned int component_index):
        cdef MemoryZone memory_zone = self.imz_components.memory_zone
        cdef EmitterStruct* pointer = <EmitterStruct*>(
            memory_zone.get_pointer(component_index))
        self.entity_components.remove_entity(pointer.entity_id)
        super(EmitterSystem, self).remove_component(component_index)


Factory.register('EmitterSystem', cls=EmitterSystem)