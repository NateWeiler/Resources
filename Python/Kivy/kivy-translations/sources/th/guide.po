# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-04 17:12\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: th\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.9.0\n"

# 952754730cac4bcb8e008f4cbade533f
#: ../../sources/guide/android.rst:4
msgid "Kivy on Android"
msgstr ""

# d358212c88d84adc805ecb108fc9b651
#: ../../sources/guide/android.rst:7
msgid "Requirements for android application"
msgstr ""

# a8f2448d163b4814b85dc25fbbb26267
#: ../../sources/guide/android.rst:9
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

# 6c3cfd28228747dcb66a9121c40a1210
#: ../../sources/guide/android.rst:17
msgid "Create an APK"
msgstr ""

# 41391ae84f1644dabf9cb1198d15a5cc
#: ../../sources/guide/android.rst:19
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

# 2d242cf83288496781357ec182245c62
#: ../../sources/guide/android.rst:23
msgid "Debugging your application on android platform"
msgstr ""

# 2a588648ff084dbabdcd8936ded49cde
#: ../../sources/guide/android.rst:25
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

# c470bfe1f74b462281c586cc9a1cf729
#: ../../sources/guide/android.rst:29
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

# 3ece23ed88884940a9952cd7e8b110a1
#: ../../sources/guide/android.rst:33
msgid "Status of the Project"
msgstr ""

# 961d3eae9efc4e5cb373037b3eb528c9
#: ../../sources/guide/android.rst:35
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

# adf441f71ba84dfeaa1c4400ca5d7171
#: ../../sources/guide/android.rst:40
msgid "This project code is available at::"
msgstr ""

# 0e06e04f6afe4ef7a348cbd5aa7e9694
#: ../../sources/guide/android.rst:44
msgid "We made that branch to be able to:"
msgstr ""

# 28a24a10f89640259cf23c0e894a6b76
#: ../../sources/guide/android.rst:46
msgid "integrate Kivy android-support branch in the build"
msgstr ""

# 69b89269f7114c709361725fd80f0ae6
#: ../../sources/guide/android.rst:47
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

# 66cfe7add18e47beb803ec4cd5d2e5d8
#: ../../sources/guide/android.rst:48
msgid "enable multitouch event"
msgstr ""

# 4e9fbc6f04bd4254af7456200ca1c359
#: ../../sources/guide/android.rst:49
msgid "custom start.pyx to launch kivy application"
msgstr ""

# 63279580352f4c79a11710f6b4ebb2a4
#: ../../sources/guide/android.rst:50
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

# e6eb177b56a14bbe881e4e064b22be3d
#: ../../sources/guide/android.rst:52
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

# 7b042689757b484393265a79feb2a3f4
#: ../../sources/guide/android.rst:54
msgid "*Video providers* (done in 1.0.8 version)"
msgstr ""

# 896baccc08434c5592c04a66ee7c6978
#: ../../sources/guide/android.rst:55
msgid "Camera providers"
msgstr ""

# ad180d7aff1049b9a9899e052748397a
#: ../../sources/guide/android.rst:56
msgid "Audio (can use RenPySound) providers"
msgstr ""

# ceb5f2ff4a4348c48280d9e5b52c692a
#: ../../sources/guide/android.rst:57
msgid "Keyboard mapping for main button"
msgstr ""

# a983a73649cc42b4b30d28148632bd1f
#: ../../sources/guide/android.rst:58
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

# fb3d6860ba1d4df8bbfa3204d737f685
#: ../../sources/guide/android.rst:61
msgid "Tested Devices"
msgstr ""

# 0237bd3c0054412f9198dac9e08fc4ff
#: ../../sources/guide/android.rst:63
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

# b6d1372908ea45ce8991720865897e8f
#: ../../sources/guide/android.rst:70
msgid "Phones"
msgstr ""

# 72914779015d4ad6a89b9bf992aedb46
#: ../../sources/guide/android.rst:72
msgid "Motorola Droid 1"
msgstr ""

# 3f104fd0fb9e4ef6ad9d7a0e55c9cd07
#: ../../sources/guide/android.rst:73
msgid "Motorola Droid 2"
msgstr ""

# 824701fb46f4451d8dfe1c7089639d05
#: ../../sources/guide/android.rst:74
msgid "HTC Desire"
msgstr ""

# cabc362e08704b8e858d1f35b3c84930
#: ../../sources/guide/android.rst:75
msgid "HTC Desire Z"
msgstr ""

# f75fb0584c3640608d56c9971c905ce6
#: ../../sources/guide/android.rst:76
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

# f684405027b44fa2aa36540b8daa0d9e
#: ../../sources/guide/android.rst:79
msgid "Tablets"
msgstr ""

# b78ff871462148e69ece0e044d2da891
#: ../../sources/guide/android.rst:81
msgid "Samsung Galaxy Tab"
msgstr ""

# d1aca6d3287a441c87e6f8e0c1b94acd
#: ../../sources/guide/android.rst:82
msgid "Motorola Xoom"
msgstr ""

# 756e49ab41c04b64959865de2aab5854
#: ../../sources/guide/android.rst:83
msgid "Asus EeePad Transformer"
msgstr ""

# f0f85b1113f2442685597a36376e1eac
#: ../../sources/guide/architecture.rst:4
msgid "Architectural Overview"
msgstr ""

# 786bf74965b34adcaed5e272965586ba
#: ../../sources/guide/architecture.rst:6
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

# 20b42e6509ae42f4a55d5454bc4df29e
#: ../../sources/guide/architecture.rst:15
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

# bf781729a3504fdc9c36579a1e8b904d
#: ../../sources/guide/architecture.rst:22
msgid "Core Providers and Input Providers"
msgstr ""

# 5a96c09d7a284b5c863faef84425b587
#: ../../sources/guide/architecture.rst:24
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

# f80dc1ac2a2c4d038069835401e73ad9
#: ../../sources/guide/architecture.rst:42
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

# d906296a441445b9b0253578ce8feb96
#: ../../sources/guide/architecture.rst:51
msgid "Graphics"
msgstr ""

# 9b18926f0dfc468eadf087a4919f7ccd
#: ../../sources/guide/architecture.rst:53
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

# 135c8b6fcb184aefb6ff23c98ac16304
#: ../../sources/guide/architecture.rst:60
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

# 0f6201d8e86144039c69c4556cb3d411
#: ../../sources/guide/architecture.rst:63
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

# 92b3154bf29f44ce987b0495cc984fe1
#: ../../sources/guide/architecture.rst:68
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

# b71039bd66014b1387ddd2ae7c1eceef
#: ../../sources/guide/architecture.rst:74
msgid "Core"
msgstr ""

# f557ea18073a402eb8728964ab297902
#: ../../sources/guide/architecture.rst:76
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

# 6fd5913068cd4b8089c178206e8396f5
#: ../../sources/guide/architecture.rst:79
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

# 5eb6dc3d681e4f8ba7a8c22514b86c32
#: ../../sources/guide/architecture.rst:83
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

# e59cd7a5b40d41819471e481e6374f34
#: ../../sources/guide/architecture.rst:87
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

# 6a2a0e25fbc644f1ac10752bfee06423
#: ../../sources/guide/architecture.rst:92
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

# 8e40175abd004379bbbd1fc55559e8bf
#: ../../sources/guide/architecture.rst:96
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

# c380e3ec345b467fa266983ab8122a72
#: ../../sources/guide/architecture.rst:102
msgid "UIX (Widgets & Layouts)"
msgstr ""

# 4aaa07c0e52d4ca1826f23508a888d3d
#: ../../sources/guide/architecture.rst:104
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

# c83266406ec549fd9887c4fe995677dd
#: ../../sources/guide/architecture.rst:108
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

# 8cb2285c262f4f1190ead8f0752c529f
#: ../../sources/guide/architecture.rst:114
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

# 62b7f2ea40fe4c0482192da0cdacaa40
#: ../../sources/guide/architecture.rst:122
msgid "Modules"
msgstr ""

# 17918fe6ad894343bacf4a17c5ba680a
#: ../../sources/guide/architecture.rst:124
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

# 15515aceeb1a4ddba6c16bd256c338dd
#: ../../sources/guide/architecture.rst:129
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

# 330dd2f6bfde470aa58c79031cb0a59a
#: ../../sources/guide/architecture.rst:132
msgid "You can also write your own modules."
msgstr ""

# b3390639b713489c8553ec231329d31e
#: ../../sources/guide/architecture.rst:136
msgid "Input Events (Touches)"
msgstr ""

# dc5bc114f97e4c1a924f6b282ba2248e
#: ../../sources/guide/architecture.rst:138
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

# 3ba09dd1b5bd432baf7dc40bc85a1338
#: ../../sources/guide/architecture.rst:145
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

# 2021fff2cc96463d888262b80f379cdc
#: ../../sources/guide/architecture.rst:155
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

# c652b496654e426e9c84eb5bf2e1bdac
#: ../../sources/guide/architecture.rst:158
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

# e67976cae5a743c08cfd2a213c8aafa0
#: ../../sources/guide/architecture.rst:162
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

# b7d5e4ee50d9424eb1a512e3dddf0dde
#: ../../sources/guide/architecture.rst:171
msgid "Widgets and Event Dispatching"
msgstr ""

# 17b8e7d72cb44859b2969208e2ecfaad
#: ../../sources/guide/architecture.rst:173
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

# 1e0a151cd7bb45e28f3f3888696687e7
#: ../../sources/guide/architecture.rst:183
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

# 975dabdcfa744f6f8fec134aebc3edbb
#: ../../sources/guide/architecture.rst:191
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

# fa1a526dc9a84c998e7f0290a6dda77f
#: ../../sources/guide/architecture.rst:206
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

# df13336eefc545a1b485dffc8672fe22
#: ../../sources/guide/architecture.rst:210
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

# 6622b0558e9f4949a5415f6fb280070b
#: ../../sources/guide/config.rst:2
msgid "Configure Kivy"
msgstr ""

# 70d219f780474806ae053bd7aa6b26da
#: ../../sources/guide/config.rst:4
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

# d46bb947ebab40139642b11b235d7567
#: ../../sources/guide/config.rst:8
msgid "Locating the configuration file"
msgstr ""

# a29597b540d54209b61820d4757d2338
#: ../../sources/guide/config.rst:10
msgid "The location of the configuration file is in::"
msgstr ""

# 284f235b5c26492e92ed94073d8df559
#: ../../sources/guide/config.rst:14
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

# 2c970af74ebb4eb586141bf67d91924f
#: ../../sources/guide/config.rst:16
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

# 113ff5ad1c3545ed8de2b80b2a313040
#: ../../sources/guide/config.rst:17
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

# e01faa48989444669062e422a1f75691
#: ../../sources/guide/config.rst:18
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

# c9199cb27c574acab83188c318af53f9
#: ../../sources/guide/config.rst:22
msgid "Understanding config tokens"
msgstr ""

# bd0f7c6de1fd46d89b35ecfa91b03c62
#: ../../sources/guide/config.rst:24
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

# a718caa1d7d04865927ba7bde365ea85
#: ../../sources/guide/designwithkv.rst:7
msgid "Designing with Kivy language"
msgstr ""

# 80dfaf5d91ee4a80b16f4a0e68cfa4a3
#: ../../sources/guide/designwithkv.rst:9
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

# 4d58f039ed2042d39fb9294231e80ba9
#: ../../sources/guide/designwithkv.rst:14
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

# 30df876a3f124d12a1fe7e118e4abe2c
#: ../../sources/guide/designwithkv.rst:16
msgid "`info` for receving some text"
msgstr ""

# e08cf264f5ae492d9ebd266b84288ee9
#: ../../sources/guide/designwithkv.rst:17
msgid "`label_wid` for receving the label widget"
msgstr ""

# 85ee76ab1ffd4c269837cbfa6c594136
#: ../../sources/guide/designwithkv.rst:19
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

# b7d0c8e2f80c4f7399a8d7268ab05fdc
#: ../../sources/guide/designwithkv.rst:23
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

# 683e6be2b0a546bda3f606da26188971
#: ../../sources/guide/designwithkv.rst:32
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

# 7fdcfba9c3d345ec910ce85da39d239f
#: ../../sources/guide/designwithkv.rst:34
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

# 1bf25b2bef39450aba8dcb2adf52cbb6
#: ../../sources/guide/designwithkv.rst:38
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

# adce2da049fa499a92ac2e9aaf399c39
#: ../../sources/guide/designwithkv.rst:43
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

# b339b9211c8d49d89c75cf55b1189a2e
#: ../../sources/guide/designwithkv.rst:45
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

# c5b2f9f630fd45099453d51e49422f13
#: ../../sources/guide/designwithkv.rst:49
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

# 00e199783146441ca2d4e4ae99cff9e9
#: ../../sources/guide/environment.rst:4
msgid "Controling the environment"
msgstr ""

# d649b03d27fa434d83bc6bd96dcd4007
#: ../../sources/guide/environment.rst:6
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

# 5302292aeca44babab6e653554820f5a
#: ../../sources/guide/environment.rst:9
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

# 103984e205614c88ac8bc79e3acd31b3
#: ../../sources/guide/environment.rst:13
msgid "Environment variable can be set before importing kivy::"
msgstr ""

# 345d2b9a6b324d92b841ed95cc34fc52
#: ../../sources/guide/environment.rst:20
msgid "Configuration"
msgstr ""

# 99f98eb663384dea9913b7f5b7c05cfe
#: ../../sources/guide/environment.rst:23
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

# c81912d478b04706bc2905704a15868c
#: ../../sources/guide/environment.rst:26
msgid "Path control"
msgstr ""

# 70f2e5c048ae4d57b427a49ab9688656
#: ../../sources/guide/environment.rst:30
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

# 1c8f2f8abc2f41079041a75e899e7fb1
#: ../../sources/guide/environment.rst:34
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

# f24ffa9e06b94909b40376ba38a3f0bc
#: ../../sources/guide/environment.rst:37
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

# e49470c4e7924f46931fbbd8e337652a
#: ../../sources/guide/environment.rst:40
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

# b96d0238379f48c4855e40488084a985
#: ../../sources/guide/environment.rst:43
msgid "Restrict core to specific implementation"
msgstr ""

# 1bc4056d1a1542e88cbb0982958b3dbd
#: ../../sources/guide/environment.rst:45
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

# a7e9a7ee39554ad1ba5779b6ea4a2c88
#: ../../sources/guide/environment.rst:50
msgid "Implementation to use for creating the Window"
msgstr ""

# 3b629f82d8a948a5bc4398742ccf6dbb
#: ../../sources/guide/environment.rst:52
msgid "Values: pygame"
msgstr ""

# 1216f8008e504051a6dc7f5999eea2a8
#: ../../sources/guide/environment.rst:55
msgid "Implementation to use for rendering text"
msgstr ""

# 65d6bb3080364a239e1838c119fcc40c
#: ../../sources/guide/environment.rst:57
msgid "Values: pil, cairo, pygame"
msgstr ""

# 8ef75afb2f0642eb881a205c96a9a1cc
#: ../../sources/guide/environment.rst:60
msgid "Implementation to use for rendering video"
msgstr ""

# 2189daaef9e54174872ed2e9e1b98177
#: ../../sources/guide/environment.rst:62
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

# ce0a3c1103f14bc4a89dc3fa6c723875
#: ../../sources/guide/environment.rst:65
msgid "Implementation to use for playing audio"
msgstr ""

# ef2506d124954ec4941eeb8799db4dd6
#: ../../sources/guide/environment.rst:67
msgid "Values: gstreamer, pygame"
msgstr ""

# 2d679f8f80914bff99f27bd1f6c8514d
#: ../../sources/guide/environment.rst:70
msgid "Implementation to use for reading image"
msgstr ""

# 6c7dbf048bc54c56bbe011edc71bcb9d
#: ../../sources/guide/environment.rst:72
msgid "Values: pil, pygame"
msgstr ""

# 19e6a07838aa411fbc30f57f6b77e3d0
#: ../../sources/guide/environment.rst:75
msgid "Implementation to use for reading camera"
msgstr ""

# 417ec2ff43914907b8e31d394363ae26
#: ../../sources/guide/environment.rst:77
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

# 58fbfab2aff84dae9df2c539752d64a1
#: ../../sources/guide/environment.rst:80
msgid "Implementation to use for spelling"
msgstr ""

# 578e37ec0e58447184d6627670453d1a
#: ../../sources/guide/environment.rst:82
msgid "Values: enchant, osxappkit"
msgstr ""

# c4e5c86396384ee8873a5dfb48fbd667
#: ../../sources/guide/environment.rst:85
msgid "Implementation to use for clipboard management"
msgstr ""

# b4933a583523413a985645c92a1efb71
#: ../../sources/guide/environment.rst:87
msgid "Values: pygame, dummy"
msgstr ""

# 0fa2ee26f5a6429489bba8f1544b9bef
#: ../../sources/guide/events.rst:2
msgid "Events"
msgstr ""

# 4e466c0e17e047e49bd536b0ad351dba
#: ../../sources/guide/events.rst:4
msgid "You have 2 types of events living in Kivy:"
msgstr ""

# 71c8eea4ad3b40ada9063ac79d861e70
#: ../../sources/guide/events.rst:6
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

# d07f024b89e9496b8109c8ea19226c2a
#: ../../sources/guide/events.rst:8
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

# 9cbeb3f365554ea696dd00eab7ce321b
#: ../../sources/guide/events.rst:13
msgid "Clock events"
msgstr ""

# 3beb3d1ad0da47f7bd6b62b3f49998d1
#: ../../sources/guide/events.rst:15
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

# 4abb7f58fcae4665929257faf6b351f8
#: ../../sources/guide/events.rst:25
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

# 0fc73fdabdb94bcbad970bc2a2dbdb93
#: ../../sources/guide/events.rst:30
msgid "Scheduling an repetitive event"
msgstr ""

# 27a0399bd7ff43eda0f41718a5b8233e
#: ../../sources/guide/events.rst:32
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

# 1c507827207a4f00b59c72343f6ad964
#: ../../sources/guide/events.rst:40
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

# 80f8e911fb614a6295aeca2a39f5c7a1
#: ../../sources/guide/events.rst:45
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

# ea2674c214264507a6142cd5af772e71
#: ../../sources/guide/events.rst:60
msgid "Scheduling an one-time call event"
msgstr ""

# 26a293133a91468ca10cb96d3c23772b
#: ../../sources/guide/events.rst:62
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

# 70fcca0aa6fd4ff0a6b7dcac0efd5f81
#: ../../sources/guide/events.rst:69
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

# cdb6af606dbb4f008f07fb03c04ca5c9
#: ../../sources/guide/events.rst:72
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

# bf9ba347e8af47d8828524130d301f67
#: ../../sources/guide/events.rst:73
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

# bbe9958e87654a2d879dd9c1d6449d65
#: ../../sources/guide/events.rst:74
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

# 4ef8dbcd3d6a4ba386c1717ee97fa857
#: ../../sources/guide/events.rst:77
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

# dc53bbc44af845dfbd4746aa7092fc59
#: ../../sources/guide/events.rst:82
msgid "Trigger events"
msgstr ""

# c42e96806b474730845825a29e425a16
#: ../../sources/guide/events.rst:84
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

# 39b8830e7cce49a6923301a700484aba
#: ../../sources/guide/events.rst:90
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

# f7a5ef711b02475abed9d7a9a5965bd3
#: ../../sources/guide/events.rst:99
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

# fc9229be6c774b93ac82868360f3b102
#: ../../sources/guide/events.rst:106
msgid "Widget events"
msgstr ""

# eea9f2e52221413b8da65f21799714de
#: ../../sources/guide/events.rst:108
msgid "A widget have 2 types of events:"
msgstr ""

# 5bc6a9fb7cd04d44a9c2241d13e3da7a
#: ../../sources/guide/events.rst:110
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

# b0794bbc26bc4f03a2e79d7941cf3101
#: ../../sources/guide/events.rst:112
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

# d890a65652f2416d934568c6d31569f8
#: ../../sources/guide/events.rst:117
msgid "Property event"
msgstr ""

# 0546cddcf4ac4b3fa3b3c7909eaf0109
#: ../../sources/guide/events.rst:119
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

# dab773f412dd4148bc8c53bd7b2b8383
#: ../../sources/guide/events.rst:124
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

# 9d6e18060fdf4c88a91f7ca7413b04e5
#: ../../sources/guide/events.rst:131
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

# 1a07c2ab668d46e6b7790ecb76815b9e
#: ../../sources/guide/events.rst:138
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

# c915af9b96a14ea5bdb5ec17b8a03f71
#: ../../sources/guide/events.rst:151
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

# 5c619f30be2947cdbc85ee9aaf436991
#: ../../sources/guide/events.rst:157
msgid "Widget defined event"
msgstr ""

# bc8c8e591be04ed2b9563b09e4c0379a
#: ../../sources/guide/events.rst:159
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

# 82744863a891461fbeea77bc21fd7f96
#: ../../sources/guide/events.rst:170
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

# accc3e23d9ac453ea12c56d656dd37a6
#: ../../sources/guide/events.rst:173
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

# 9c1a588c36cb4c8c8b6d42aa1bb03f6c
#: ../../sources/guide/events.rst:185
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

# 18de841cda064fedac53af7a6326334e
#: ../../sources/guide/events.rst:196
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

# d3e96f36bbcc4806a66f2a1d4575c898
#: ../../sources/guide/firstwidget.rst:7
msgid "Your First Widget"
msgstr ""

# f6a02caaa4c841a29ec3b5b23713eb6c
#: ../../sources/guide/firstwidget.rst:9
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

# 335c44297cbf430ebed7a01810035a29
#: ../../sources/guide/firstwidget.rst:16
msgid "Basic Considerations"
msgstr ""

# a553d19cbdfb4c7b9e9406d31d1c9df6
#: ../../sources/guide/firstwidget.rst:18
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

# ae9e8f3689004361b65b53803b432f24
#: ../../sources/guide/firstwidget.rst:20
msgid "What data does my application process?"
msgstr ""

# 99fa02292df44fffa4de6a6cb3e782a8
#: ../../sources/guide/firstwidget.rst:21
msgid "How do I visually represent that data?"
msgstr ""

# 0f21ad53149b4bf7b6f32ead35b5a5d2
#: ../../sources/guide/firstwidget.rst:22
msgid "How does the user interact with that data?"
msgstr ""

# d6f9bb6603154f63bba1a8db3dde9eb7
#: ../../sources/guide/firstwidget.rst:24
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

# d65e17d0fdb1462798611fb7fc5ddd8d
#: ../../sources/guide/firstwidget.rst:32
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

# ac425743d22c429da57aebe3a06a066d
#: ../../sources/guide/firstwidget.rst:45
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

# 55c75592182a4743bf7e1f964549c739
#: ../../sources/guide/firstwidget.rst:52
msgid "Paint Widget"
msgstr ""

# 029cf349cf4049afba8d10704e09a9a2
#: ../../sources/guide/firstwidget.rst:54
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

# 46d4f48c2b674faeafc14f8223be8547
#: ../../sources/guide/firstwidget.rst:63
msgid "Initial Structure"
msgstr ""

# 3f616de9f84347aa89afadeca3cf2824
#: ../../sources/guide/firstwidget.rst:65
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

# 1c9887f623b3455785c702ddb5b826af
#: ../../sources/guide/firstwidget.rst:75
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

# 6448ffb4328b40b397d6d6465edae955
#: ../../sources/guide/firstwidget.rst:89
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

# 1232819018f14f55a9ffdf879152d053
#: ../../sources/guide/firstwidget.rst:98
msgid "Adding Behaviour"
msgstr ""

# 4af2579e193c42e7bed30e2adea43a28
#: ../../sources/guide/firstwidget.rst:100
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

# 62fe29d5fd0f43b18f5e4edec6e4dd38
#: ../../sources/guide/firstwidget.rst:107
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

# 26974ace8a58435c9d551b5ae27914ac
#: ../../sources/guide/firstwidget.rst:115
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

# 76ea82119a4e453a83ae4595508d70a9
#: ../../sources/guide/firstwidget.rst:124
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

# 721a3fc41f52467dbed963ed43b1d865
#: ../../sources/guide/firstwidget.rst:128
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

# a1917fb71b1840c7abf10b8fb01c8950
#: ../../sources/guide/firstwidget.rst:135
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

# 1225ee1372394378b852b63107f58aeb
#: ../../sources/guide/firstwidget.rst:141
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

# 28c10900612b450bafd6f9e9b1ebe3c2
#: ../../sources/guide/firstwidget.rst:145
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

# 331ec880263f4bfba2cd29081c45f207
#: ../../sources/guide/firstwidget.rst:155
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

# 4d0ce8231d3045a8a03999fb466486e9
#: ../../sources/guide/firstwidget.rst:165
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

# 00d4b66db72f40318eb5d662ba7ea974
#: ../../sources/guide/firstwidget.rst:172
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

# 7e4007236c3548bcbe04b822932d1f35
#: ../../sources/guide/firstwidget.rst:177
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

# 97ac476bc7fb4bbeb39af3b58ed52bac
#: ../../sources/guide/firstwidget.rst:186
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

# 8fb74769080a48e49c4c84e9ca8bd428
#: ../../sources/guide/firstwidget.rst:194
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

# 90d17b5b33aa49c193d84b184e3199bc
#: ../../sources/guide/firstwidget.rst:207
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

# 559ef71b28ac4aa3af92814dc1c27040
#: ../../sources/guide/firstwidget.rst:217
msgid "Here are the changes:"
msgstr ""

# c1a29ca9b553445c8beaef84968b1809
#: ../../sources/guide/firstwidget.rst:219
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

# ce9aede7a35347628cb7dcb413c0d640
#: ../../sources/guide/firstwidget.rst:221
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

# 6d5bfd1c18704cc28f3bc32062ffd343
#: ../../sources/guide/firstwidget.rst:229
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

# 291dd8bb6cf54596a248d77696e35159
#: ../../sources/guide/firstwidget.rst:238
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

# 4dc21490926e48b2b17df5a44a667633
#: ../../sources/guide/firstwidget.rst:242
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

# f5e21e82569c472b8be8fdb14dff55d3
#: ../../sources/guide/firstwidget.rst:257
msgid "Bonus Points"
msgstr ""

# 564beb8a95144260b65d3f4d5b9aeedf
#: ../../sources/guide/firstwidget.rst:259
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

# 453fcf913cb94413bd4b097187fc6745
#: ../../sources/guide/firstwidget.rst:263
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

# 71d696d6cefb4c739081e0accb6303e8
#: ../../sources/guide/firstwidget.rst:270
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

# 9798703a3cae4fa3a5d7ee63913512d6
#: ../../sources/guide/firstwidget.rst:274
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

# f55a24e17ef34f16929cad0602520e5a
#: ../../sources/guide/firstwidget.rst:277
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

# 20c19fb7273440ccb762475604646cfa
#: ../../sources/guide/firstwidget.rst:289
msgid "Here's what happens:"
msgstr ""

# 737800a26d694318843ed326d00d24c2
#: ../../sources/guide/firstwidget.rst:291
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

# 1e4e170d6cbd45a893ce8c00eb2c3bad
#: ../../sources/guide/firstwidget.rst:293
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

# 91586806f3c04309872d3f103723c306
#: ../../sources/guide/firstwidget.rst:299
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

# c53351d3433348b59632770291fe1b10
#: ../../sources/guide/firstwidget.rst:301
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

# d868d5d98ec24aae94007893a447dbf4
#: ../../sources/guide/firstwidget.rst:303
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

# 254aa0699627403db1249798182fdff2
#: ../../sources/guide/firstwidget.rst:307
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

# 60b388db70dc4a04ad4d3efabcb83ff6
#: ../../sources/guide/firstwidget.rst:313
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

# ad26fdbc083f4f31bc5d16c245e45424
#: ../../sources/guide/firstwidget.rst:317
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

# d3a926c5cb4d4027953bbd78e0026e55
#: ../../sources/guide/inputs.rst:2
msgid "Input management"
msgstr ""

# 4afaa574e5854f94b0bbaf0a4cf7a574
#: ../../sources/guide/inputs.rst:5
msgid "Input architecure"
msgstr ""

# b64a14ee13e149ebb51d27b8c7499bb4
#: ../../sources/guide/inputs.rst:7
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

# fa0cfa4f33844a62991bc9c6e85893a7
#: ../../sources/guide/inputs.rst:11
msgid "The global architecture can be resumed like that::"
msgstr ""

# 264bd51e7221421f9da882fbf565d16d
#: ../../sources/guide/inputs.rst:15
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

# 3a88bed1b1f14c928ebc06e39d5c805f
#: ../../sources/guide/inputs.rst:19
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

# f602a595f5b24aa5a7d7be6ad5438e88
#: ../../sources/guide/inputs.rst:21
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

# 5b1d030a720944758e3aa1ab408a8e8a
#: ../../sources/guide/inputs.rst:26
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

# f59f02b00a764e62ba1e24b475a77e5b
#: ../../sources/guide/inputs.rst:28
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

# 1c23a6c97b504d66a18939245e2b87ae
#: ../../sources/guide/inputs.rst:30
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

# 1f25878920f24d1e865e64aa49bb32b7
#: ../../sources/guide/inputs.rst:32
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

# 990203c205474ed9a8c36b9d2e2ae211
#: ../../sources/guide/inputs.rst:35
msgid "and lot more !"
msgstr ""

# cad611b9b0f34a14b63481409502227e
#: ../../sources/guide/inputs.rst:37
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

# 69c789ac6163458d8590bbceb7382398
#: ../../sources/guide/inputs.rst:39
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

# 4df27859a70b429d8387361de2dcd9ca
#: ../../sources/guide/inputs.rst:41
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

# a687387239454f3597f8907f89919f1c
#: ../../sources/guide/inputs.rst:42
msgid "correcting events when the hardware is not accurate"
msgstr ""

# 29b6bfd40ac74d64a634589f3196536e
#: ../../sources/guide/inputs.rst:43
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

# 4ce7e7d20345455885b2b8922e5195e7
#: ../../sources/guide/inputs.rst:46
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

# 9ff9ea8ca26746a9b002906f171e51ac
#: ../../sources/guide/inputs.rst:48
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

# 389bd209ba4b462dbd8b6410a1fe3662
#: ../../sources/guide/inputs.rst:49
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

# 6d377daa2f734425947ac33af4932e6e
#: ../../sources/guide/inputs.rst:51
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

# c9227e3456e146bab9fc248368360cbb
#: ../../sources/guide/inputs.rst:52
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

# 9ec503f70a674145852cc1c7b4b16b99
#: ../../sources/guide/inputs.rst:53
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

# 82df8ece23ad4315b2a362319641cacb
#: ../../sources/guide/inputs.rst:57
msgid "Motion event profiles"
msgstr ""

# 09936b38f02547e280868a7a0ba6432f
#: ../../sources/guide/inputs.rst:59
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

# 68d36073a6024d2ba347b11380ed7b7d
#: ../../sources/guide/inputs.rst:63
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

# 430218b670c74f52881267880f0c5de4
#: ../../sources/guide/inputs.rst:71
msgid "The print could output::"
msgstr ""

# dd969461b4f74e43a87a602b78164902
#: ../../sources/guide/inputs.rst:77
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

# 824b9d5d40f6449ca623288af93a8a39
#: ../../sources/guide/inputs.rst:81
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

# bd92e099d4224909acfbe9612706e30b
#: ../../sources/guide/inputs.rst:91
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

# dda9e4104b7c432287d5c94393f84f95
#: ../../sources/guide/inputs.rst:95
msgid "Touch events"
msgstr ""

# 73cb2dbc94d6428a9d2eb1771c6060aa
#: ../../sources/guide/inputs.rst:97
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

# d057a66fd8a54d4a8087d0ad9286bb57
#: ../../sources/guide/inputs.rst:102
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

# 54bc3b0afb9a43a99aea4f71e4ac41b7
#: ../../sources/guide/inputs.rst:104
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

# 666d3cf24ef147f493a5a37fc3951bb6
#: ../../sources/guide/inputs.rst:109
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

# 242f321938c84b0d9c58d053e8bae601
#: ../../sources/guide/inputs.rst:111
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

# 9a597612e1d74aa4a4ba9df15696ba92
#: ../../sources/guide/inputs.rst:113
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

# 9f7ec1a786b84faebf91c2c2fcf60616
#: ../../sources/guide/inputs.rst:115
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

# befbdcf842a74e588185afebc2c44499
#: ../../sources/guide/inputs.rst:118
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

# 8ab238269f2345a68a78efc6a8697649
#: ../../sources/guide/inputs.rst:141
msgid "Touch shapes"
msgstr ""

# 287c75e55bf041efa4d14991e2178817
#: ../../sources/guide/inputs.rst:143
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

# 2b69ca2d62164a05a87aecb9620dedd5
#: ../../sources/guide/inputs.rst:154
msgid "Double tap"
msgstr ""

# b0c97baed0ea40579471ad8027033443
#: ../../sources/guide/inputs.rst:156
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

# 77904087ee504a11a2f67f1a0376af7f
#: ../../sources/guide/inputs.rst:169
msgid "Grabbing touches"
msgstr ""

# ef7e91fa922747928ddb1228d415b51c
#: ../../sources/guide/inputs.rst:171
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

# 22a4074ab9134747bd16e569e4ea9ec8
#: ../../sources/guide/inputs.rst:176
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

# 8c2879ba473e472a86fda015ce83a310
#: ../../sources/guide/inputs.rst:180
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

# 7494227f272048aebe48fa84b1d82a3d
#: ../../sources/guide/inputs.rst:182
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

# c8a80fadba814762931def9489e3d16e
#: ../../sources/guide/inputs.rst:184
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

# c5e6d15e460848a5818f370acfb8067f
#: ../../sources/guide/inputs.rst:187
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

# 5e9e442eb4bf4708a988d426926b4089
#: ../../sources/guide/inputs.rst:191
msgid "Here is an example about how to use it::"
msgstr ""

# cd27c50b2cfb4466854a9209a3678850
#: ../../sources/guide/other-frameworks.rst:5
msgid "Integrating with other Frameworks"
msgstr ""

# 9fdababf431f404897fa4f6b50648717
#: ../../sources/guide/other-frameworks.rst:9
msgid "Using Twisted inside Kivy"
msgstr ""

# 7fbd9091f1a74433b6d904b239a463c1
#: ../../sources/guide/other-frameworks.rst:12
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

# d610d8edeb0f4bd1afbf6a1d4349f892
#: ../../sources/guide/other-frameworks.rst:15
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

# ce4be58159eb46f4bdeb6f92fd2a2949
#: ../../sources/guide/other-frameworks.rst:20
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

# 756a3f3c860144acabc64102ff1a6c15
#: ../../sources/guide/other-frameworks.rst:28
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

# 0e25d6a9daf64d6ab2733015f17b63f4
#: ../../sources/guide/other-frameworks.rst:36
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

# 925938be5f58458f97439c673a6491e0
#: ../../sources/guide/other-frameworks.rst:42
msgid "Serer App"
msgstr ""

# 388cefa71f5044c5a6bb37009c8f0fd1
#: ../../sources/guide/other-frameworks.rst:47
msgid "Client App"
msgstr ""

# e926f98ca89247d9904a1d0f9e8f0846
#: ../../sources/guide/packaging.rst:4
msgid "Packaging your application"
msgstr ""

# 626a313bc63d49d8966086ff1166739b
#: ../../sources/guide/packaging-android.rst:4
msgid "Create a package for Android"
msgstr ""

# 75ba785b2e6744e78da33e0a22f77b6a
#: ../../sources/guide/packaging-android.rst:7
msgid "Packaging your application into APK"
msgstr ""

# b6a497f338a846a0b585c98eb7fc617c
#: ../../sources/guide/packaging-android.rst:9
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

# 112fff46662a4d31a4b113110ef9036a
#: ../../sources/guide/packaging-android.rst:12
msgid "Java"
msgstr ""

# 19fa27cbca71433584b7364dae483c14
#: ../../sources/guide/packaging-android.rst:13
msgid "Python 2.7 (not 2.6.)"
msgstr ""

# 2812d9c5cb0d44e49ccc7ea3f0cfee01
#: ../../sources/guide/packaging-android.rst:14
msgid "Jinja2 (python module)"
msgstr ""

# a2a7ab1e76df442bb6acf91200a2ebf5
#: ../../sources/guide/packaging-android.rst:15
msgid "Apache ant"
msgstr ""

# e689fbec0d4d4c28a9eec7ea02b620df
#: ../../sources/guide/packaging-android.rst:16
msgid "Android SDK"
msgstr ""

# 3377f35339404f15af776dcee4f7a8ff
#: ../../sources/guide/packaging-android.rst:18
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

# a0106a7989584ea68b2e4d349466b848
#: ../../sources/guide/packaging-android.rst:22
msgid "Build in debug mode"
msgstr ""

# 0f02d79d9c374b80b060b60d45338fb9
#: ../../sources/guide/packaging-android.rst:24
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

# 29321e42ce0b4d6c8d6e2ad3e832e3f1
#: ../../sources/guide/packaging-android.rst:36
msgid "The last argument stand for:"
msgstr ""

# 933d511e2baa410b8ca9317d497b93a9
#: ../../sources/guide/packaging-android.rst:38
msgid "debug: build debug version and save to bin directory"
msgstr ""

# ee4152da37574746a0113ce16b4c1af2
#: ../../sources/guide/packaging-android.rst:39
msgid "install: same as debug + upload on connected device"
msgstr ""

# 45a2b4768e8f46c392f527f15f64836a
#: ../../sources/guide/packaging-android.rst:40
msgid "release: build release version and save to bin directory"
msgstr ""

# 489dc40960f04faebec6fcfc9884f049
#: ../../sources/guide/packaging-android.rst:42
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

# c5063bb8031547088827d9ec4c35f038
#: ../../sources/guide/packaging-android.rst:49
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

# 278a4d5f793949daa2587ec7e0223159
#: ../../sources/guide/packaging-android.rst:51
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

# 1dfb289546d34a5eb2f121e9e745eaa4
#: ../../sources/guide/packaging-android.rst:55
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

# 26417cebd5564accbd12af44a2ba0a3f
#: ../../sources/guide/packaging-android.rst:58
msgid "Video support"
msgstr ""

# 6e67b18a0cbe4525ac17e60dcebce3c1
#: ../../sources/guide/packaging-android.rst:62
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

# 90efee82c59847019617b77b07b4a809
#: ../../sources/guide/packaging-android.rst:66
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

# db6c439a17ba49fcb54feeb698824942
#: ../../sources/guide/packaging-android.rst:71
msgid "Release on the market"
msgstr ""

# b7d25744e9fc4d1eb314454a7fc04b3b
#: ../../sources/guide/packaging-android.rst:73
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

# 278796a9e7c94444b869da86258460d2
#: ../../sources/guide/packaging-android.rst:76
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

# 2e17e18ff6ae4a46a4fe93da286ccddb
#: ../../sources/guide/packaging-android.rst:78
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

# 1f703bea739e49369ec600607f8eaf7b
#: ../../sources/guide/packaging-android.rst:83
msgid "Packaging your application for Kivy Launcher"
msgstr ""

# 2074384585694d5ab7b49c34e679f78d
#: ../../sources/guide/packaging-android.rst:85
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

# cd251ddc877e4f20872592eb3b73c4b0
#: ../../sources/guide/packaging-android.rst:88
msgid "Your application must be saved into::"
msgstr ""

# 0950c10adeda445ab827fbba94e9e823
#: ../../sources/guide/packaging-android.rst:92
msgid "Your application directory must contain::"
msgstr ""

# 5bbd8300b598498eb947011324b4371c
#: ../../sources/guide/packaging-android.rst:99
msgid "The file `android.txt` must contain::"
msgstr ""

# 9d1879396997484a8548e58b8fe9f325
#: ../../sources/guide/packaging-macosx.rst:2
msgid "Create package for MacOSX"
msgstr ""

# 5e7648cbf70a426983960c8781c89cd0
#: ../../sources/guide/packaging-macosx.rst:4
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

# 600109f8d82846448bd7b541421a6ff1
#: ../../sources/guide/packaging-macosx.rst:8
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

# 141912498f114f57ab02f934bdf71f9e
# db183a933b404cbeba1cacee2f21fdde
#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
msgid "Requirements"
msgstr ""

# 7549ad7115674096b26f5215083c4039
# d34ebda8517741159e4315b645b2e24b
#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

# 29071641fe9f4d36841bf064d39f2ee4
# 650c0c7bb76443fa920012a104c0cd55
#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

# 937bdb283e9149ff9b24676893972b4c
# 6053dcb96e534855b42f47df9d69538a
#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
msgid "Install and configure PyInstaller"
msgstr ""

# d8693de8836148d5b4917c7a4808d6c2
#: ../../sources/guide/packaging-macosx.rst:20
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

# 32bc211581da4943b5f8679a44232781
#: ../../sources/guide/packaging-macosx.rst:23
msgid "Decompress the PyInstaller"
msgstr ""

# a0f9e56f5cf2467b8d93cb2c4696ca91
#: ../../sources/guide/packaging-macosx.rst:24
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

# 4adf161d523e4533b17dfe5478f37c43
#: ../../sources/guide/packaging-macosx.rst:25
msgid "Execute the following::"
msgstr ""

# e09fd25869884da5864f8190323bcd31
#: ../../sources/guide/packaging-macosx.rst:37
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

# 241941e583264b3cb282d1579cd6b85a
# 8bcac083578e4fd396f258ee74a664b0
#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
msgid "Create the spec file"
msgstr ""

# 80103e315df545a2a47495068e22d074
#: ../../sources/guide/packaging-macosx.rst:42
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

# 217a5b8ecc6f4c998e26d8b2f61be54f
# f5faa0679f3a4cb4ba008056d072493b
#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
msgid "Open a console"
msgstr ""

# 02968b8ae5a74f4ba7805b33b03d16e0
# 4d1f9ee7c4374386b6d03cc481fc55da
#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

# c1d072ab782947e58ea2d524140b21fb
# 30e2a79fcb0c4f18937eb33bbfa28abd
#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

# 16debb8822da449c9136e021a38500a4
# 60368fac80d04387b27c2b4141eb23db
#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

# 9557afd6667848d8b1ee9e909cf4c097
# 199a019b2fcd45bca668f87513e1bae0
#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
msgid "This is done, your spec is ready to be executed !"
msgstr ""

# bae96f39538342c39ecc53f2442256a3
#: ../../sources/guide/packaging-macosx.rst:74
msgid "Build the spec and create DMG"
msgstr ""

# 704fdf92e75d46b5973c423198ec5c0e
# badb700cf29b4d118dccf6421c576b3f
#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

# fde60c0ed6b64e98aac53dda0563b1e5
#: ../../sources/guide/packaging-macosx.rst:82
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

# e1006c054dcf4a909c260456121d36d3
#: ../../sources/guide/packaging-macosx.rst:89
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

# d68f6c46cfaf429d9d215c273bb70521
#: ../../sources/guide/packaging-windows.rst:2
msgid "Create package for Windows"
msgstr ""

# 06aabb6a3cb44dcd89dcc98501717ef1
#: ../../sources/guide/packaging-windows.rst:4
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

# 75e91374770e4b0c9af20c740345462e
#: ../../sources/guide/packaging-windows.rst:8
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

# 2e61795b80e842a58fdb2ea83fabe02d
#: ../../sources/guide/packaging-windows.rst:20
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

# 3fcf1a17376d42b5be6156271ece6604
# bb563329aaa9485e947a8a668d6ffcec
#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

# d4e1c01944ee44889518998782d4392f
#: ../../sources/guide/packaging-windows.rst:22
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

# 01c1367ed1bd49ea9c7b0c8fd60601f8
#: ../../sources/guide/packaging-windows.rst:30
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

# afa173b36ae44e9c9b91ea4d6fb51070
#: ../../sources/guide/packaging-windows.rst:40
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

# 649de635b7cc47549e1509042cf54fcf
#: ../../sources/guide/packaging-windows.rst:66
msgid "Build the spec"
msgstr ""

# afe7360c503c46e2a7b2abcb1c27ff50
#: ../../sources/guide/packaging-windows.rst:68
msgid "Double click on Kivy.bat"
msgstr ""

# 083c420bc18f479f93e71f11321e26c2
#: ../../sources/guide/packaging-windows.rst:74
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

# 3068b6ccff3c440dbdf205c15415c321
#: ../../sources/guide/platform.rst:2
msgid "Running on Mobile Platforms"
msgstr ""

# f87c36ec4e6646d69ef5cc15872848aa
#: ../../sources/guide/quickstart.rst:4
msgid "Quickstart"
msgstr ""

# 5426b5fe6f27478d8428b98e53ba2e9c
#: ../../sources/guide/quickstart.rst:6
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

# 4877fb1897834b069ac54108f8e6c1a9
#: ../../sources/guide/quickstart.rst:13
msgid "Create an application"
msgstr ""

# 906537acf69643b7ba3e26e1ed5c748e
#: ../../sources/guide/quickstart.rst:15
msgid "The base code for creating an application looks like this:"
msgstr ""

# f495cd4a30bc4068b0e964848c5be08f
#: ../../sources/guide/quickstart.rst:32
msgid "Save it as `main.py`."
msgstr ""

# 2fc9d18a79f749c48ce2bb1d88f35190
#: ../../sources/guide/quickstart.rst:34
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

# b04734d070be4f83848fe6fd0ff7cdae
#: ../../sources/guide/quickstart.rst:37
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

# 082da66837174a2f94545b6f7cf6d918
#: ../../sources/guide/quickstart.rst:42
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

# 98c60a27867f4649b42c54aee82ea054
#: ../../sources/guide/quickstart.rst:49
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

# e0dca6e8b67544daac794d2206d77cf9
#: ../../sources/guide/quickstart.rst:54
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

# 444370269a3a4b5bbd9c08b9463237e4
#: ../../sources/guide/quickstart.rst:57
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

# 41f461fb9bb6410bbbc07a8219010ebd
#: ../../sources/guide/quickstart.rst:63
msgid "So what does that code do?"
msgstr ""

# af744052896c4d7a9f77a79d1c49df05
#: ../../sources/guide/quickstart.rst:65
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

# 01d23313adef479896638f37d91daeab
#: ../../sources/guide/quickstart.rst:69
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

# 7211421984934ebb85f061d7fcc3b4a4
#: ../../sources/guide/quickstart.rst:73
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

# df3d8f31de4b406cb923794eb6e73c44
#: ../../sources/guide/quickstart.rst:75
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

# c0bb9526c36546fba163ccf520ed3aa9
#: ../../sources/guide/quickstart.rst:79
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

# 51f05cc03f754169aa1ff5aa0cdccc31
#: ../../sources/guide/readingdoc.rst:2
msgid "How to read the documentation"
msgstr ""

# 5522c1893773402e86615ebc1bb8bf3d
#: ../../sources/guide/readingdoc.rst:4
msgid "The documentation is seperated in 2 parts:"
msgstr ""

# 0c9a3f7d16e44720bf43077bfeae8a28
#: ../../sources/guide/readingdoc.rst:6
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

# 64062002eac847fda4c8b939d91ed9ae
#: ../../sources/guide/readingdoc.rst:8
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

# 83b5a8f9034f4f10aa4c0476053ad5b2
#: ../../sources/guide/readingdoc.rst:12
msgid "Importing a class"
msgstr ""

# b3a2f004df0545daa4d8f03987ce38a6
#: ../../sources/guide/readingdoc.rst:14
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

# 77d1a25a33a741109bd7edfd5ae4b993
#: ../../sources/guide/readingdoc.rst:19
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

# e0b255c76f9d4af8b6a56f3a258fcfc8
#: ../../sources/guide/widgettree.rst:4
msgid "Widget tree"
msgstr ""

# 38c3d18e7d404e2486ac69b02c4d2af1
#: ../../sources/guide/widgettree.rst:6
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

# 76f518e8912d441e8d68e9b78ed1a75f
#: ../../sources/guide/widgettree.rst:10
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

# 47ef3c5049ed4701be38c879524310db
#: ../../sources/guide/widgettree.rst:14
msgid "Manipulating the tree"
msgstr ""

# de87f217f50c4842ad98921d9e158f4a
#: ../../sources/guide/widgettree.rst:16
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

# ed5fe537342e4b54a86c75a8d829ce56
#: ../../sources/guide/widgettree.rst:18
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

# 0939e638175048a18695189d54567ab6
#: ../../sources/guide/widgettree.rst:19
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

# da5a7e99dc5845ecb676c3378140f007
#: ../../sources/guide/widgettree.rst:21
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

# 21528d2c7cd544c0bef7fd628233941a
#: ../../sources/guide/widgettree.rst:24
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

# f92d844967194769a56005ffe06cc004
#: ../../sources/guide/widgettree.rst:30
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

# 3d698ecf187e4775a2188a4a63808e6a
#: ../../sources/guide/widgettree.rst:35
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

# 242a541f89cb4641bc5515ed6314df26
#: ../../sources/guide/widgettree.rst:38
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

# 0e9d0096bb184dc7afed2e63ab0bfa07
#: ../../sources/guide/widgettree.rst:45
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

# cb16b6e9e76545af8ccea134f73684e4
#: ../../sources/guide/widgettree.rst:54
msgid "Traversing the tree"
msgstr ""

# 42ffeb11814b4b55b242923d317703e9
#: ../../sources/guide/widgettree.rst:56
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

# 3d2f25dd609044089b252855d412e065
#: ../../sources/guide/widgettree.rst:64
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""
