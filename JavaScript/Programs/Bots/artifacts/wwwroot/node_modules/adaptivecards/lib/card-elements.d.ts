import * as Enums from "./enums";
import * as Utils from "./utils";
import * as HostConfig from "./host-config";
export declare function createActionInstance(parent: CardElement, json: any, errors: Array<HostConfig.IValidationError>): Action;
export declare function createElementInstance(parent: CardElement, json: any, errors: Array<HostConfig.IValidationError>): CardElement;
export declare class SpacingDefinition {
    left: number;
    top: number;
    right: number;
    bottom: number;
    constructor(top?: number, right?: number, bottom?: number, left?: number);
}
export declare class PaddingDefinition {
    top: Enums.Spacing;
    right: Enums.Spacing;
    bottom: Enums.Spacing;
    left: Enums.Spacing;
    constructor(top?: Enums.Spacing, right?: Enums.Spacing, bottom?: Enums.Spacing, left?: Enums.Spacing);
    toSpacingDefinition(hostConfig: HostConfig.HostConfig): SpacingDefinition;
}
export declare class SizeAndUnit {
    physicalSize: number;
    unit: Enums.SizeUnit;
    static parse(input: any): SizeAndUnit;
    constructor(physicalSize: number, unit: Enums.SizeUnit);
}
export interface IResourceInformation {
    url: string;
    mimeType: string;
}
export interface ICardObject {
    shouldFallback(): boolean;
    setParent(parent: CardElement): any;
    parse(json: any): any;
}
export declare abstract class CardElement implements ICardObject {
    private _shouldFallback;
    private _lang;
    private _hostConfig?;
    private _internalPadding;
    private _parent;
    private _renderedElement;
    private _separatorElement;
    private _isVisible;
    private _truncatedDueToOverflow;
    private _defaultRenderedElementDisplayMode;
    private _padding;
    private internalRenderSeparator;
    private updateRenderedElementVisibility;
    private hideElementDueToOverflow;
    private showElementHiddenDueToOverflow;
    private handleOverflow;
    private resetOverflow;
    protected createPlaceholderElement(): HTMLElement;
    protected internalGetNonZeroPadding(padding: PaddingDefinition, processTop?: boolean, processRight?: boolean, processBottom?: boolean, processLeft?: boolean): void;
    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
    protected abstract internalRender(): HTMLElement;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected isDesignMode(): boolean;
    protected readonly useDefaultSizing: boolean;
    protected readonly allowCustomPadding: boolean;
    protected readonly defaultPadding: PaddingDefinition;
    protected internalPadding: PaddingDefinition;
    protected readonly separatorOrientation: Enums.Orientation;
    protected getPadding(): PaddingDefinition;
    protected setPadding(value: PaddingDefinition): void;
    readonly requires: HostConfig.HostCapabilities;
    id: string;
    speak: string;
    horizontalAlignment?: Enums.HorizontalAlignment;
    spacing: Enums.Spacing;
    separator: boolean;
    height: "auto" | "stretch";
    customCssSelector: string;
    abstract getJsonTypeName(): string;
    abstract renderSpeech(): string;
    toJSON(): {};
    setParent(value: CardElement): void;
    getNonZeroPadding(): PaddingDefinition;
    getForbiddenElementTypes(): Array<string>;
    getForbiddenActionTypes(): Array<any>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getActionCount(): number;
    getActionAt(index: number): Action;
    validate(): Array<HostConfig.IValidationError>;
    remove(): boolean;
    render(): HTMLElement;
    updateLayout(processChildren?: boolean): void;
    indexOf(cardElement: CardElement): number;
    isRendered(): boolean;
    isAtTheVeryTop(): boolean;
    isFirstElement(element: CardElement): boolean;
    isAtTheVeryBottom(): boolean;
    isLastElement(element: CardElement): boolean;
    isAtTheVeryLeft(): boolean;
    isBleeding(): boolean;
    isLeftMostElement(element: CardElement): boolean;
    isAtTheVeryRight(): boolean;
    isRightMostElement(element: CardElement): boolean;
    isHiddenDueToOverflow(): boolean;
    canContentBleed(): boolean;
    getRootElement(): CardElement;
    getParentContainer(): Container;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<IResourceInformation>;
    getElementById(id: string): CardElement;
    getActionById(id: string): Action;
    shouldFallback(): boolean;
    setShouldFallback(value: boolean): void;
    lang: string;
    hostConfig: HostConfig.HostConfig;
    readonly index: number;
    readonly isInteractive: boolean;
    readonly isStandalone: boolean;
    readonly parent: CardElement;
    isVisible: boolean;
    readonly hasVisibleSeparator: boolean;
    readonly renderedElement: HTMLElement;
    readonly separatorElement: HTMLElement;
}
export declare abstract class CardElementContainer extends CardElement {
    abstract getItemCount(): number;
    abstract getItemAt(index: number): CardElement;
    abstract removeItem(item: CardElement): boolean;
}
export declare class TextBlock extends CardElement {
    private _computedLineHeight;
    private _originalInnerHtml;
    private _text;
    private _processedText;
    private _treatAsPlainText;
    private _selectAction;
    private _effectiveStyleDefinition;
    private restoreOriginalContent;
    private truncateIfSupported;
    private getEffectiveStyleDefinition;
    protected getRenderedDomElementType(): string;
    protected internalRender(): HTMLElement;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    size: Enums.TextSize;
    weight: Enums.TextWeight;
    color: Enums.TextColor;
    isSubtle: boolean;
    wrap: boolean;
    maxLines: number;
    useMarkdown: boolean;
    toJSON(): {};
    applyStylesTo(targetElement: HTMLElement): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getJsonTypeName(): string;
    renderSpeech(): string;
    updateLayout(processChildren?: boolean): void;
    text: string;
    selectAction: Action;
}
export declare class Fact {
    name: string;
    value: string;
    speak: string;
    constructor(name?: string, value?: string);
    toJSON(): {
        title: string;
        value: string;
    };
    renderSpeech(): string;
}
export declare class FactSet extends CardElement {
    protected readonly useDefaultSizing: boolean;
    protected internalRender(): HTMLElement;
    facts: Array<Fact>;
    getJsonTypeName(): string;
    toJSON(): {};
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    renderSpeech(): string;
}
export declare class Image extends CardElement {
    private _selectAction;
    private parseDimension;
    private applySize;
    protected readonly useDefaultSizing: boolean;
    protected internalRender(): HTMLElement;
    style: Enums.ImageStyle;
    backgroundColor: string;
    url: string;
    size: Enums.Size;
    width: Utils.SizeAndUnit;
    pixelWidth?: number;
    pixelHeight?: number;
    altText: string;
    toJSON(): {};
    getJsonTypeName(): string;
    getActionById(id: string): Action;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getResourceInformation(): Array<IResourceInformation>;
    renderSpeech(): string;
    selectAction: Action;
}
export declare class ImageSet extends CardElementContainer {
    private _images;
    protected internalRender(): HTMLElement;
    imageSize: Enums.Size;
    getItemCount(): number;
    getItemAt(index: number): CardElement;
    getResourceInformation(): Array<IResourceInformation>;
    removeItem(item: CardElement): boolean;
    getJsonTypeName(): string;
    toJSON(): {};
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    addImage(image: Image): void;
    indexOf(cardElement: CardElement): number;
    renderSpeech(): string;
}
export declare class MediaSource {
    mimeType: string;
    url: string;
    constructor(url?: string, mimeType?: string);
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): {
        mimeType: string;
        url: string;
    };
}
export declare class Media extends CardElement {
    static readonly supportedMediaTypes: string[];
    private _selectedMediaType;
    private _selectedSources;
    private getPosterUrl;
    private processSources;
    private renderPoster;
    private renderMediaPlayer;
    protected internalRender(): HTMLElement;
    static onPlay: (sender: Media) => void;
    sources: Array<MediaSource>;
    poster: string;
    altText: string;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): {};
    getJsonTypeName(): string;
    getResourceInformation(): Array<IResourceInformation>;
    renderSpeech(): string;
    readonly selectedMediaType: string;
}
export declare abstract class Input extends CardElement implements Utils.IInput {
    protected valueChanged(): void;
    abstract readonly value: string;
    onValueChanged: (sender: Input) => void;
    title: string;
    defaultValue: string;
    toJSON(): {};
    validate(): Array<HostConfig.IValidationError>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    renderSpeech(): string;
    getAllInputs(): Array<Input>;
    readonly isInteractive: boolean;
}
export declare class TextInput extends Input {
    private _textareaElement;
    private _inputElement;
    protected internalRender(): HTMLElement;
    maxLength: number;
    isMultiline: boolean;
    placeholder: string;
    style: Enums.InputTextStyle;
    getJsonTypeName(): string;
    toJSON(): {};
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly value: string;
}
export declare class ToggleInput extends Input {
    private _checkboxInputElement;
    protected internalRender(): HTMLElement;
    valueOn: string;
    valueOff: string;
    getJsonTypeName(): string;
    toJSON(): {};
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly value: string;
}
export declare class Choice {
    title: string;
    value: string;
    constructor(title?: string, value?: string);
    toJSON(): {
        title: string;
        value: string;
    };
}
export declare class ChoiceSetInput extends Input {
    private static uniqueCategoryCounter;
    private static getUniqueCategoryName;
    private _selectElement;
    private _toggleInputs;
    protected internalRender(): HTMLElement;
    choices: Array<Choice>;
    isCompact: boolean;
    isMultiSelect: boolean;
    placeholder: string;
    getJsonTypeName(): string;
    toJSON(): {};
    validate(): Array<HostConfig.IValidationError>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly value: string;
}
export declare class NumberInput extends Input {
    private _numberInputElement;
    protected internalRender(): HTMLElement;
    min: string;
    max: string;
    placeholder: string;
    getJsonTypeName(): string;
    toJSON(): {};
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly value: string;
}
export declare class DateInput extends Input {
    private _dateInputElement;
    protected internalRender(): HTMLElement;
    getJsonTypeName(): string;
    readonly value: string;
}
export declare class TimeInput extends Input {
    private _timeInputElement;
    protected internalRender(): HTMLElement;
    getJsonTypeName(): string;
    readonly value: string;
}
export declare abstract class Action implements ICardObject {
    private _shouldFallback;
    private _parent;
    private _actionCollection;
    private _renderedElement;
    private setCollection;
    protected addCssClasses(element: HTMLElement): void;
    abstract getJsonTypeName(): string;
    readonly requires: HostConfig.HostCapabilities;
    id: string;
    title: string;
    iconUrl: string;
    isPrimary: boolean;
    onExecute: (sender: Action) => void;
    toJSON(): {};
    render(): void;
    setParent(value: CardElement): void;
    execute(): void;
    setStatus(status: any): void;
    validate(): Array<HostConfig.IValidationError>;
    prepare(inputs: Array<Input>): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    remove(): boolean;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<IResourceInformation>;
    getActionById(id: string): Action;
    readonly parent: CardElement;
    readonly renderedElement: HTMLElement;
    shouldFallback(): boolean;
}
export declare class SubmitAction extends Action {
    private _isPrepared;
    private _originalData;
    private _processedData;
    getJsonTypeName(): string;
    toJSON(): {};
    prepare(inputs: Array<Input>): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    data: Object;
}
export declare class OpenUrlAction extends Action {
    url: string;
    getJsonTypeName(): string;
    toJSON(): {};
    validate(): Array<HostConfig.IValidationError>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
}
export declare class HttpHeader {
    private _value;
    name: string;
    constructor(name?: string, value?: string);
    toJSON(): {
        name: string;
        value: string;
    };
    prepare(inputs: Array<Input>): void;
    value: string;
}
export declare class HttpAction extends Action {
    private _url;
    private _body;
    private _headers;
    method: string;
    getJsonTypeName(): string;
    toJSON(): {};
    validate(): Array<HostConfig.IValidationError>;
    prepare(inputs: Array<Input>): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    url: string;
    body: string;
    headers: Array<HttpHeader>;
}
export declare class ShowCardAction extends Action {
    protected addCssClasses(element: HTMLElement): void;
    readonly card: AdaptiveCard;
    getJsonTypeName(): string;
    toJSON(): {};
    validate(): Array<HostConfig.IValidationError>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    setParent(value: CardElement): void;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<IResourceInformation>;
    getActionById(id: string): Action;
}
export declare class ActionSet extends CardElement {
    private _actionCollection;
    protected internalRender(): HTMLElement;
    orientation?: Enums.Orientation;
    constructor();
    toJSON(): {};
    isBleeding(): boolean;
    getJsonTypeName(): string;
    getActionCount(): number;
    getActionAt(index: number): Action;
    validate(): Array<HostConfig.IValidationError>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    addAction(action: Action): void;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<IResourceInformation>;
    renderSpeech(): string;
    readonly isInteractive: boolean;
}
export declare class BackgroundImage {
    url: string;
    mode: Enums.BackgroundImageMode;
    horizontalAlignment: Enums.HorizontalAlignment;
    verticalAlignment: Enums.VerticalAlignment;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    apply(element: HTMLElement): void;
}
export declare class Container extends CardElementContainer {
    private _selectAction;
    private _items;
    private _renderedItems;
    private _style?;
    private isElementAllowed;
    private insertItemAt;
    private readonly hasExplicitStyle;
    protected getItemsCollectionPropertyName(): string;
    protected isLastElementBleeding(): boolean;
    protected applyPadding(): void;
    protected internalRender(): HTMLElement;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected readonly hasBackground: boolean;
    protected readonly defaultStyle: string;
    protected readonly allowCustomStyle: boolean;
    backgroundImage: BackgroundImage;
    verticalContentAlignment: Enums.VerticalAlignment;
    rtl?: boolean;
    toJSON(): {};
    getItemCount(): number;
    getItemAt(index: number): CardElement;
    getJsonTypeName(): string;
    isBleeding(): boolean;
    isFirstElement(element: CardElement): boolean;
    isLastElement(element: CardElement): boolean;
    isRtl(): boolean;
    validate(): Array<HostConfig.IValidationError>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    indexOf(cardElement: CardElement): number;
    addItem(item: CardElement): void;
    insertItemBefore(item: CardElement, insertBefore: CardElement): void;
    insertItemAfter(item: CardElement, insertAfter: CardElement): void;
    removeItem(item: CardElement): boolean;
    clear(): void;
    canContentBleed(): boolean;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<IResourceInformation>;
    getElementById(id: string): CardElement;
    getActionById(id: string): Action;
    renderSpeech(): string;
    updateLayout(processChildren?: boolean): void;
    style: string;
    padding: PaddingDefinition;
    selectAction: Action;
}
export declare type ColumnWidth = Utils.SizeAndUnit | "auto" | "stretch";
export declare class Column extends Container {
    private _computedWeight;
    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
    protected readonly separatorOrientation: Enums.Orientation;
    width: ColumnWidth;
    constructor(width?: ColumnWidth);
    getJsonTypeName(): string;
    toJSON(): {};
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly hasVisibleSeparator: boolean;
    readonly isStandalone: boolean;
}
export declare class ColumnSet extends CardElementContainer {
    private _columns;
    private _selectAction;
    protected applyPadding(): void;
    protected internalRender(): HTMLElement;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    toJSON(): {};
    isFirstElement(element: CardElement): boolean;
    getCount(): number;
    getItemCount(): number;
    getColumnAt(index: number): Column;
    getItemAt(index: number): CardElement;
    getJsonTypeName(): string;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    validate(): Array<HostConfig.IValidationError>;
    updateLayout(processChildren?: boolean): void;
    addColumn(column: Column): void;
    removeItem(item: CardElement): boolean;
    indexOf(cardElement: CardElement): number;
    isLeftMostElement(element: CardElement): boolean;
    isRightMostElement(element: CardElement): boolean;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<IResourceInformation>;
    getElementById(id: string): CardElement;
    getActionById(id: string): Action;
    renderSpeech(): string;
    padding: PaddingDefinition;
    selectAction: Action;
}
export interface ITypeRegistration<T> {
    typeName: string;
    createInstance: () => T;
}
export declare abstract class ContainerWithActions extends Container {
    private _actionCollection;
    protected readonly renderIfEmpty: boolean;
    protected internalRender(): HTMLElement;
    protected isLastElementBleeding(): boolean;
    constructor();
    toJSON(): {};
    getActionCount(): number;
    getActionAt(index: number): Action;
    getActionById(id: string): Action;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    validate(): Array<HostConfig.IValidationError>;
    isLastElement(element: CardElement): boolean;
    addAction(action: Action): void;
    clear(): void;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<IResourceInformation>;
    readonly isStandalone: boolean;
}
export declare abstract class TypeRegistry<T> {
    private _items;
    private findTypeRegistration;
    constructor();
    clear(): void;
    abstract reset(): any;
    registerType(typeName: string, createInstance: () => T): void;
    unregisterType(typeName: string): void;
    createInstance(typeName: string): T;
    getItemCount(): number;
    getItemAt(index: number): ITypeRegistration<T>;
}
export declare class ElementTypeRegistry extends TypeRegistry<CardElement> {
    reset(): void;
}
export declare class ActionTypeRegistry extends TypeRegistry<Action> {
    reset(): void;
}
export interface IMarkdownProcessingResult {
    didProcess: boolean;
    outputHtml?: any;
}
export declare class AdaptiveCard extends ContainerWithActions {
    private static currentVersion;
    static useAutomaticContainerBleeding: boolean;
    static useAdvancedTextBlockTruncation: boolean;
    static useAdvancedCardBottomTruncation: boolean;
    static useMarkdownInRadioButtonAndCheckbox: boolean;
    static allowMarkForTextHighlighting: boolean;
    static readonly elementTypeRegistry: ElementTypeRegistry;
    static readonly actionTypeRegistry: ActionTypeRegistry;
    static onAnchorClicked: (element: CardElement, anchor: HTMLAnchorElement) => boolean;
    static onExecuteAction: (action: Action) => void;
    static onElementVisibilityChanged: (element: CardElement) => void;
    static onImageLoaded: (image: Image) => void;
    static onInlineCardExpanded: (action: ShowCardAction, isExpanded: boolean) => void;
    static onParseElement: (element: CardElement, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    static onParseAction: (element: Action, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    static onParseError: (error: HostConfig.IValidationError) => void;
    static onProcessMarkdown: (text: string, result: IMarkdownProcessingResult) => void;
    static processMarkdown: (text: string) => string;
    static applyMarkdown(text: string): IMarkdownProcessingResult;
    private _cardTypeName?;
    private _fallbackCard;
    private isVersionSupported;
    protected readonly renderIfEmpty: boolean;
    protected getItemsCollectionPropertyName(): string;
    protected applyPadding(): void;
    protected internalRender(): HTMLElement;
    protected readonly bypassVersionCheck: boolean;
    protected readonly defaultPadding: PaddingDefinition;
    protected readonly allowCustomPadding: boolean;
    protected readonly allowCustomStyle: boolean;
    protected readonly hasBackground: boolean;
    onAnchorClicked: (element: CardElement, anchor: HTMLAnchorElement) => boolean;
    onExecuteAction: (action: Action) => void;
    onElementVisibilityChanged: (element: CardElement) => void;
    onImageLoaded: (image: Image) => void;
    onInlineCardExpanded: (action: ShowCardAction, isExpanded: boolean) => void;
    onParseElement: (element: CardElement, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    onParseAction: (element: Action, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    version?: HostConfig.Version;
    fallbackText: string;
    designMode: boolean;
    getJsonTypeName(): string;
    toJSON(): {};
    validate(): Array<HostConfig.IValidationError>;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    render(target?: HTMLElement): HTMLElement;
    updateLayout(processChildren?: boolean): void;
    canContentBleed(): boolean;
    shouldFallback(): boolean;
    readonly hasVisibleSeparator: boolean;
}
